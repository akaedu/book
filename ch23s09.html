<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9. 不完全类型和复杂声明</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch23.html" title="第 23 章 指针" /><link rel="prev" href="ch23s08.html" title="8. 函数类型和函数指针类型" /><link rel="next" href="ch24.html" title="第 24 章 函数接口" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9. 不完全类型和复杂声明</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch23s08.html">上一页</a> </td><th width="60%" align="center">第 23 章 指针</th><td width="20%" align="right"> <a accesskey="n" href="ch24.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2813989"></a>9. 不完全类型和复杂声明</h2></div></div></div><p>在<a class="xref" href="ch07s01.html#struct.intro">第 1 节 “复合类型与结构体”</a>讲过算术类型、标量类型的概念，现在又学习了几种类型，我们完整地总结一下C语言的类型。下图出自<a class="xref" href="bi01.html#bibli.standardc" title="Standard C: A Reference">[<abbr class="abbrev">Standard C</abbr>]</a>。</p><div class="figure"><a id="id2814014"></a><p class="title"><b>图 23.5. C语言类型总结</b></p><div class="figure-contents"><div><img src="images/pointer.type.gif" alt="C语言类型总结" /></div></div></div><br class="figure-break" /><p>C语言的类型分为函数类型、对象类型和不完全类型三大类。对象类型又分为标量类型和非标量类型。指针类型属于标量类型，因此也可以做逻辑与、或、非运算的操作数和<code class="literal">if</code>、<code class="literal">for</code>、<code class="literal">while</code>的控制表达式，<code class="literal">NULL</code>指针表示假，非<code class="literal">NULL</code>指针表示真。不完全类型是暂时没有完全定义好的类型，编译器不知道这种类型该占几个字节的存储空间，例如：</p><pre class="programlisting">struct s;
union u;
char str[];</pre><p>具有不完全类型的变量可以通过多次声明组合成一个完全类型，比如数组<code class="literal">str</code>声明两次：</p><pre class="programlisting">char str[];
char str[10];</pre><p>当编译器碰到第一个声明时，认为<code class="literal">str</code>是一个不完全类型，碰到第二个声明时<code class="literal">str</code>就组合成完全类型了，如果编译器处理到程序文件的末尾仍然无法把<code class="literal">str</code>组合成一个完全类型，就会报错。读者可能会想，这个语法有什么用呢？为何不在第一次声明时就把<code class="literal">str</code>声明成完全类型？有些情况下这么做有一定的理由，比如第一个声明是写在头文件里的，第二个声明写在<code class="literal">.c</code>文件里，这样如果要改数组长度，只改<code class="literal">.c</code>文件就行了，头文件可以不用改。</p><p>不完全的结构体类型有重要作用：</p><pre class="programlisting">struct s {
	struct t *pt;
};

struct t {
	struct s *ps;
};</pre><p><code class="literal">struct s</code>和<code class="literal">struct t</code>各有一个指针成员指向另一种类型。编译器从前到后依次处理，当看到<code class="literal">struct s { struct t* pt; };</code>时，认为<code class="literal">struct t</code>是一个不完全类型，<code class="literal">pt</code>是一个指向不完全类型的指针，尽管如此，这个指针却是完全类型，因为不管什么指针都占4个字节存储空间，这一点很明确。然后编译器又看到<code class="literal">struct t { struct s *ps; };</code>，这时<code class="literal">struct t</code>有了完整的定义，就组合成一个完全类型了，<code class="literal">pt</code>的类型就组合成一个指向完全类型的指针。由于<code class="literal">struct s</code>在前面有完整的定义，所以<code class="literal">struct s *ps;</code>也定义了一个指向完全类型的指针。</p><p>这样的类型定义是错误的：</p><pre class="programlisting">struct s {
	struct t ot;
};

struct t {
	struct s os;
};</pre><p>编译器看到<code class="literal">struct s { struct t ot; };</code>时，认为<code class="literal">struct t</code>是一个不完全类型，无法定义成员<code class="literal">ot</code>，因为不知道它该占几个字节。所以结构体中可以递归地定义指针成员，但不能递归地定义变量成员，你可以设想一下，假如允许递归地定义变量成员，<code class="literal">struct s</code>中有一个<code class="literal">struct t</code>，<code class="literal">struct t</code>中又有一个<code class="literal">struct s</code>，<code class="literal">struct s</code>又中有一个<code class="literal">struct t</code>，这就成了一个无穷递归的定义。</p><p>以上是两个结构体构成的递归定义，一个结构体也可以递归定义：</p><pre class="programlisting">struct s {
	char data[6];
	struct s* next;
};</pre><p>当编译器处理到第一行<code class="literal">struct s {</code>时，认为<code class="literal">struct s</code>是一个不完全类型，当处理到第三行<code class="literal">struct s *next;</code>时，认为<code class="literal">next</code>是一个指向不完全类型的指针，当处理到第四行<code class="literal">};</code>时，<code class="literal">struct s</code>成了一个完全类型，<code class="literal">next</code>也成了一个指向完全类型的指针。类似这样的结构体是很多种数据结构的基本组成单元，如链表、二叉树等，我们将在后面详细介绍。下图示意了由几个<code class="literal">struct s</code>结构体组成的链表，这些结构体称为链表的节点（Node）<a id="id2814359" class="indexterm"></a>。</p><div class="figure"><a id="id2814368"></a><p class="title"><b>图 23.6. 链表</b></p><div class="figure-contents"><div><img src="images/pointer.linkedlist.png" alt="链表" /></div></div></div><br class="figure-break" /><p><code class="literal">head</code>指针是链表的头指针，指向第一个节点，每个节点的<code class="literal">next</code>指针域指向下一个节点，最后一个节点的<code class="literal">next</code>指针域为<code class="literal">NULL</code>，在图中用0表示。</p><p>可以想像得到，如果把指针和数组、函数、结构体层层组合起来可以构成非常复杂的类型，下面看几个复杂的声明。</p><pre class="programlisting">typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);</pre><p>这个声明来自<code class="literal">signal(2)</code>。<code class="literal">sighandler_t</code>是一个函数指针，它所指向的函数带一个参数，返回值为<code class="literal">void</code>，<code class="literal">signal</code>是一个函数，它带两个参数，一个<code class="literal">int</code>参数，一个<code class="literal">sighandler_t</code>参数，返回值也是<code class="literal">sighandler_t</code>参数。如果把这两行合成一行写，就是：</p><pre class="programlisting">void (*signal(int signum, void (*handler)(int)))(int);</pre><p>在分析复杂声明时，要借助<code class="literal">typedef</code>把复杂声明分解成几种基本形式：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">T *p;</code>，<code class="literal">p</code>是指向<code class="literal">T</code>类型的指针。</p></li><li><p><code class="literal">T a[];</code>，<code class="literal">a</code>是由<code class="literal">T</code>类型的元素组成的数组，但有一个例外，如果<code class="literal">a</code>是函数的形参，则相当于<code class="literal">T *a;</code></p></li><li><p><code class="literal">T1 f(T2, T3...);</code>，<code class="literal">f</code>是一个函数，参数类型是<code class="literal">T2</code>、<code class="literal">T3</code>等等，返回值类型是<code class="literal">T1</code>。</p></li></ul></div><p>我们分解一下这个复杂声明：</p><pre class="programlisting">int (*(*fp)(void *))[10];</pre><p>1、<code class="literal">fp</code>和<code class="literal">*</code>号括在一起，说明<code class="literal">fp</code>是一个指针，指向<code class="literal">T1</code>类型：</p><pre class="programlisting">typedef int (*T1(void *))[10];
T1 *fp;</pre><p>2、<code class="literal">T1</code>应该是一个函数类型，参数是<code class="literal">void *</code>，返回值是<code class="literal">T2</code>类型：</p><pre class="programlisting">typedef int (*T2)[10];
typedef T2 T1(void *);
T1 *fp;</pre><p>3、<code class="literal">T2</code>和<code class="literal">*</code>号括在一起，应该也是个指针，指向<code class="literal">T3</code>类型：</p><pre class="programlisting">typedef int T3[10];
typedef T3 *T2;
typedef T2 T1(void *);
T1 *fp;</pre><p>显然，<code class="literal">T3</code>是一个<code class="literal">int</code>数组，由10个元素组成。分解完毕。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch23s08.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch23.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch24.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">8. 函数类型和函数指针类型 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 24 章 函数接口</td></tr></table></div></body></html>
