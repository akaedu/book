<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5. 常用的make命令行选项</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch22.html" title="第 22 章 Makefile基础" /><link rel="prev" href="ch22s04.html" title="4. 自动处理头文件的依赖关系" /><link rel="next" href="ch23.html" title="第 23 章 指针" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. 常用的<code class="literal">make</code>命令行选项</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch22s04.html">上一页</a> </td><th width="60%" align="center">第 22 章 Makefile基础</th><td width="20%" align="right"> <a accesskey="n" href="ch23.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2806383"></a>5. 常用的<code class="literal">make</code>命令行选项</h2></div></div></div><p><code class="literal">-n</code>选项只打印要执行的命令，而不会真的执行命令，这个选项有助于我们检查Makefile写得是否正确，由于Makefile不是顺序执行的，用这个选项可以先看看命令的执行顺序，确认无误了再真正执行命令。</p><p><code class="literal">-C</code>选项可以切换到另一个目录执行那个目录下的Makefile，比如先退到上一级目录再执行我们的Makefile（假设我们的源代码都放在<code class="literal">testmake</code>目录下）：</p><pre class="screen">$ cd ..
$ make -C testmake
make: Entering directory `/home/akaedu/testmake'
cc    -c -o main.o main.c
cc    -c -o stack.o stack.c
cc    -c -o maze.o maze.c
gcc main.o stack.o maze.o -o main
make: Leaving directory `/home/akaedu/testmake'</pre><p>一些规模较大的项目会把不同的模块或子系统的源代码放在不同的子目录中，然后在每个子目录下都写一个该目录的Makefile，然后在一个总的Makefile中用<code class="literal">make -C</code>命令执行每个子目录下的Makefile。例如Linux内核源代码根目录下有<code class="literal">Makefile</code>，子目录<code class="literal">fs</code>、<code class="literal">net</code>等也有各自的<code class="literal">Makefile</code>，二级子目录<code class="literal">fs/ramfs</code>、<code class="literal">net/ipv4</code>等也有各自的<code class="literal">Makefile</code>。</p><p>在<code class="literal">make</code>命令行也可以用<code class="literal">=</code>或<code class="literal">:=</code>定义变量，如果这次编译我想加调试选项<code class="literal">-g</code>，但我不想每次编译都加<code class="literal">-g</code>选项，可以在命令行定义<code class="literal">CFLAGS</code>变量，而不必修改Makefile编译完了再改回来：</p><pre class="screen">$ make CFLAGS=-g
cc -g   -c -o main.o main.c
cc -g   -c -o stack.o stack.c
cc -g   -c -o maze.o maze.c
gcc main.o stack.o maze.o -o main</pre><p>如果在Makefile中也定义了<code class="literal">CFLAGS</code>变量，则命令行的值覆盖Makefile中的值。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch22s04.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch22.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch23.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">4. 自动处理头文件的依赖关系 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 23 章 指针</td></tr></table></div></body></html>
