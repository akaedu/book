<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2. Shell如何执行命令</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch31.html" title="第 31 章 Shell脚本" /><link rel="prev" href="ch31s01.html" title="1. Shell的历史" /><link rel="next" href="ch31s03.html" title="3. Shell的基本语法" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Shell如何执行命令</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch31s01.html">上一页</a> </td><th width="60%" align="center">第 31 章 Shell脚本</th><td width="20%" align="right"> <a accesskey="n" href="ch31s03.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2872012"></a>2. Shell如何执行命令</h2></div></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2872017"></a>2.1. 执行交互式命令</h3></div></div></div><p>用户在命令行输入命令后，一般情况下Shell会<code class="literal">fork</code>并<code class="literal">exec</code>该命令，但是Shell的内建命令例外，执行内建命令相当于调用Shell进程中的一个函数，并不创建新的进程。以前学过的<code class="literal">cd</code>、<code class="literal">alias</code>、<code class="literal">umask</code>、<code class="literal">exit</code>等命令即是内建命令，凡是用<code class="literal">which</code>命令查不到程序文件所在位置的命令都是内建命令，内建命令没有单独的man手册，要在man手册中查看内建命令，应该</p><pre class="screen">$ man bash-builtins</pre><p>本节会介绍很多内建命令，如<code class="literal">export</code>、<code class="literal">shift</code>、<code class="literal">if</code>、<code class="literal">eval</code>、<code class="literal">[</code>、<code class="literal">for</code>、<code class="literal">while</code>等等。内建命令虽然不创建新的进程，但也会有Exit Status，通常也用0表示成功非零表示失败，虽然内建命令不创建新的进程，但执行结束后也会有一个状态码，也可以用特殊变量<code class="literal">$?</code>读出。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2872131"></a>习题</h4></div></div></div><p>1、在完成<a class="xref" href="ch30s05.html#process.implementshell">第 5 节 “练习：实现简单的Shell”</a>时也许有的读者已经试过了，在自己实现的Shell中不能执行<code class="literal">cd</code>命令，因为<code class="literal">cd</code>是一个内建命令，没有程序文件，不能用<code class="literal">exec</code>执行。现在请完善该程序，实现<code class="literal">cd</code>命令的功能，用<code class="literal">chdir(2)</code>函数可以改变进程的当前工作目录。</p><p>2、思考一下，为什么<code class="literal">cd</code>命令要实现成内建命令？可不可以实现一个独立的<code class="literal">cd</code>程序，例如<code class="literal">/bin/cd</code>，就像<code class="literal">/bin/ls</code>一样？</p></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2872211"></a>2.2. 执行脚本</h3></div></div></div><p>首先编写一个简单的脚本，保存为<code class="literal">script.sh</code>：</p><div class="example"><a id="id2872225"></a><p class="title"><b>例 31.1. 简单的Shell脚本</b></p><div class="example-contents"><pre class="programlisting">#! /bin/sh

cd ..
ls</pre></div></div><br class="example-break" /><p>Shell脚本中用<code class="literal">#</code>表示注释，相当于C语言的<code class="literal">//</code>注释。但如果<code class="literal">#</code>位于第一行开头，并且是<code class="literal">#!</code>（称为Shebang<a id="id2872262" class="indexterm"></a>）则例外，它表示该脚本使用后面指定的解释器<code class="literal">/bin/sh</code>解释执行。如果把这个脚本文件加上可执行权限然后执行：</p><pre class="screen">$ chmod +x script.sh
$ ./script.sh</pre><p>Shell会<code class="literal">fork</code>一个子进程并调用<code class="literal">exec</code>执行<code class="literal">./script.sh</code>这个程序，<code class="literal">exec</code>系统调用应该把子进程的代码段替换成<code class="literal">./script.sh</code>程序的代码段，并从它的<code class="literal">_start</code>开始执行。然而<code class="literal">script.sh</code>是个文本文件，根本没有代码段和<code class="literal">_start</code>函数，怎么办呢？其实<code class="literal">exec</code>还有另外一种机制，如果要执行的是一个文本文件，并且第一行用Shebang指定了解释器，则用解释器程序的代码段替换当前进程，并且从解释器的<code class="literal">_start</code>开始执行，而这个文本文件被当作命令行参数传给解释器。因此，执行上述脚本相当于执行程序</p><pre class="screen">$ /bin/sh ./script.sh</pre><p>以这种方式执行不需要<code class="literal">script.sh</code>文件具有可执行权限。再举个例子，比如某个<code class="literal">sed</code>脚本的文件名是<code class="literal">script</code>，它的开头是</p><pre class="programlisting">#! /bin/sed -f</pre><p>执行<code class="literal">./script</code>相当于执行程序</p><pre class="screen">$ /bin/sed -f ./script.sh</pre><p>以上介绍了两种执行Shell脚本的方法：</p><pre class="screen">$ ./script.sh
$ sh ./script.sh</pre><p>这两种方法本质上是一样的，执行上述脚本的步骤为：</p><div class="figure"><a id="id2872410"></a><p class="title"><b>图 31.1. Shell脚本的执行过程</b></p><div class="figure-contents"><div><img src="images/shellscript.shellexec.png" alt="Shell脚本的执行过程" /></div></div></div><br class="figure-break" /><div class="orderedlist"><ol type="1"><li><p>交互Shell（<code class="literal">bash</code>）<code class="literal">fork</code>/<code class="literal">exec</code>一个子Shell（<code class="literal">sh</code>）用于执行脚本，父进程<code class="literal">bash</code>等待子进程<code class="literal">sh</code>终止。</p></li><li><p><code class="literal">sh</code>读取脚本中的<code class="literal">cd ..</code>命令，调用相应的函数执行内建命令，改变当前工作目录为上一级目录。</p></li><li><p><code class="literal">sh</code>读取脚本中的<code class="literal">ls</code>命令，<code class="literal">fork</code>/<code class="literal">exec</code>这个程序，列出当前工作目录下的文件，<code class="literal">sh</code>等待<code class="literal">ls</code>终止。</p></li><li><p><code class="literal">ls</code>终止后，<code class="literal">sh</code>继续执行，读到脚本文件末尾，<code class="literal">sh</code>终止。</p></li><li><p><code class="literal">sh</code>终止后，<code class="literal">bash</code>继续执行，打印提示符等待用户输入。</p></li></ol></div><p>如果将命令行下输入的命令用()括号括起来，那么也会<code class="literal">fork</code>出一个子Shell执行小括号中的命令，一行中可以输入由分号;隔开的多个命令，比如：</p><pre class="screen">$ (cd ..;ls -l)</pre><p>和上面两种方法执行Shell脚本的效果是相同的，<code class="literal">cd ..</code>命令改变的是子Shell的<code class="literal">PWD</code>，而不会影响到交互式Shell。然而命令</p><pre class="screen">$ cd ..;ls -l</pre><p>则有不同的效果，<code class="literal">cd ..</code>命令是直接在交互式Shell下执行的，改变交互式Shell的<code class="literal">PWD</code>，然而这种方式相当于这样执行Shell脚本：</p><pre class="screen">$ source ./script.sh</pre><p>或者</p><pre class="screen">$ . ./script.sh</pre><p><code class="literal">source</code>或者<code class="literal">.</code>命令是Shell的内建命令，这种方式也不会创建子Shell，而是直接在交互式Shell下逐行执行脚本中的命令。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2872645"></a>习题</h4></div></div></div><p>1、解释如下命令的执行过程：</p><pre class="screen">$ (exit 2)
$ echo $?
2</pre></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch31s01.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch31.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch31s03.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">1. Shell的历史 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 3. Shell的基本语法</td></tr></table></div></body></html>
