<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>6. 指向指针的指针与指针数组</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch23.html" title="第 23 章 指针" /><link rel="prev" href="ch23s05.html" title="5. 指针与结构体" /><link rel="next" href="ch23s07.html" title="7. 指向数组的指针与多维数组" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">6. 指向指针的指针与指针数组</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch23s05.html">上一页</a> </td><th width="60%" align="center">第 23 章 指针</th><td width="20%" align="right"> <a accesskey="n" href="ch23s07.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2812522"></a>6. 指向指针的指针与指针数组</h2></div></div></div><p>指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外一个指针变量，称为指向指针的指针。</p><pre class="programlisting">int i;
int *pi = &amp;i;
int **ppi = &amp;pi;</pre><p>这样定义之后，表达式<code class="literal">*ppi</code>取<code class="literal">pi</code>的值，表达式<code class="literal">**ppi</code>取<code class="literal">i</code>的值。请读者自己画图理解<code class="literal">i</code>、<code class="literal">pi</code>、<code class="literal">ppi</code>这三个变量之间的关系。</p><p>很自然地，也可以定义指向“<span class="quote">指向指针的指针</span>”的指针，但是很少用到：</p><pre class="programlisting">int ***p;</pre><p>数组中的每个元素可以是基本类型，也可以复合类型，因此也可以是指针类型。例如定义一个数组<code class="literal">a</code>由10个元素组成，每个元素都是<code class="literal">int *</code>指针：</p><pre class="programlisting">int *a[10];</pre><p>这称为指针数组。<code class="literal">int *a[10];</code>和<code class="literal">int **pa;</code>之间的关系类似于<code class="literal">int a[10];</code>和<code class="literal">int *pa;</code>之间的关系：<code class="literal">a</code>是由一种元素组成的数组，<code class="literal">pa</code>则是指向这种元素的指针。所以，如果<code class="literal">pa</code>指向<code class="literal">a</code>的首元素：</p><pre class="programlisting">int *a[10];
int **pa = &amp;a[0];</pre><p>则<code class="literal">pa[0]</code>和<code class="literal">a[0]</code>取的是同一个元素，唯一比原来复杂的地方在于这个元素是一个<code class="literal">int *</code>指针，而不是基本类型。</p><p>我们知道main函数的标准原型应该是<code class="literal">int main(int argc, char *argv[]);</code>。<code class="literal">argc</code>是命令行参数的个数。而<code class="literal">argv</code>是一个指向指针的指针，为什么不是指针数组呢？因为前面讲过，函数原型中的<code class="literal">[]</code>表示指针而不表示数组，等价于<code class="literal">char **argv</code>。那为什么要写成<code class="literal">char *argv[]</code>而不写成<code class="literal">char **argv</code>呢？这样写给读代码的人提供了有用信息，<code class="literal">argv</code>不是指向单个指针，而是指向一个指针数组的首元素。数组中每个元素都是<code class="literal">char *</code>指针，指向一个命令行参数字符串。</p><div class="example"><a id="id2812763"></a><p class="title"><b>例 23.2. 打印命令行参数</b></p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
	int i;
	for(i = 0; i &lt; argc; i++)
		printf("argv[%d]=%s\n", i, argv[i]);
	return 0;
}</pre></div></div><br class="example-break" /><p>编译执行：</p><pre class="programlisting">$ gcc main.c
$ ./a.out a b c
argv[0]=./a.out
argv[1]=a
argv[2]=b
argv[3]=c
$ ln -s a.out printargv
$ ./printargv d e 
argv[0]=./printargv
argv[1]=d
argv[2]=e</pre><p>注意程序名也算一个命令行参数，所以执行<code class="literal">./a.out a b c</code>这个命令时，<code class="literal">argc</code>是4，<code class="literal">argv</code>如下图所示：</p><div class="figure"><a id="id2812809"></a><p class="title"><b>图 23.4. <code class="literal">argv</code>指针数组</b></p><div class="figure-contents"><div><img src="images/pointer.argv.png" alt="argv指针数组" /></div></div></div><br class="figure-break" /><p>由于<code class="literal">argv[4]</code>是<code class="literal">NULL</code>，我们也可以这样循环遍历<code class="literal">argv</code>：</p><pre class="programlisting">for(i=0; argv[i] != NULL; i++)</pre><p><code class="literal">NULL</code>标识着<code class="literal">argv</code>的结尾，这个循环碰到<code class="literal">NULL</code>就结束，因而不会访问越界，这种用法很形象地称为Sentinel<a id="id2812874" class="indexterm"></a>，<code class="literal">NULL</code>就像一个哨兵守卫着数组的边界。</p><p>在这个例子中我们还看到，如果给程序建立符号链接，然后通过符号链接运行这个程序，就可以得到不同的<code class="literal">argv[0]</code>。通常，程序会根据不同的命令行参数做不同的事情，例如<code class="literal">ls -l</code>和<code class="literal">ls -R</code>打印不同的文件列表，而有些程序会根据不同的<code class="literal">argv[0]</code>做不同的事情，例如专门针对嵌入式系统的开源项目Busybox，将各种Linux命令裁剪后集于一身，编译成一个可执行文件<code class="literal">busybox</code>，安装时将<code class="literal">busybox</code>程序拷到嵌入式系统的<code class="literal">/bin</code>目录下，同时在<code class="literal">/bin</code>、<code class="literal">/sbin</code>、<code class="literal">/usr/bin</code>、<code class="literal">/usr/sbin</code>等目录下创建很多指向<code class="literal">/bin/busybox</code>的符号链接，命名为<code class="literal">cp</code>、<code class="literal">ls</code>、<code class="literal">mv</code>、<code class="literal">ifconfig</code>等等，不管执行哪个命令其实最终都是在执行<code class="literal">/bin/busybox</code>，它会根据<code class="literal">argv[0]</code>来区分不同的命令。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2813010"></a>习题</h3></div></div></div><p>1、想想以下定义中的<code class="literal">const</code>分别起什么作用？编写程序验证你的猜测。</p><pre class="programlisting">const char **p;
char *const *p;
char **const p;</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch23s05.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch23.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch23s07.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">5. 指针与结构体 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 7. 指向数组的指针与多维数组</td></tr></table></div></body></html>
