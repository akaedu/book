<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. open/close</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch28.html" title="第 28 章 文件与I/O" /><link rel="prev" href="ch28s02.html" title="2. C标准I/O库函数与Unbuffered I/O函数" /><link rel="next" href="ch28s04.html" title="4. read/write" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. open/close</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch28s02.html">上一页</a> </td><th width="60%" align="center">第 28 章 文件与I/O</th><td width="20%" align="right"> <a accesskey="n" href="ch28s04.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2851400"></a>3. open/close</h2></div></div></div><p><code class="literal">open</code>函数可以打开或创建一个文件。</p><pre class="programlisting">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
返回值：成功返回新分配的文件描述符，出错返回-1并设置errno</pre><p>在Man Page中<code class="literal">open</code>函数有两种形式，一种带两个参数，一种带三个参数，其实在C代码中<code class="literal">open</code>函数是这样声明的：</p><pre class="programlisting">int open(const char *pathname, int flags, ...);</pre><p>最后的可变参数可以是0个或1个，由<code class="literal">flags</code>参数中的标志位决定，见下面的详细说明。</p><p><code class="literal">pathname</code>参数是要打开或创建的文件名，和<code class="literal">fopen</code>一样，<code class="literal">pathname</code>既可以是相对路径也可以是绝对路径。<code class="literal">flags</code>参数有一系列常数值可供选择，可以同时选择多个常数用按位或运算符连接起来，所以这些常数的宏定义都以<code class="literal">O_</code>开头，表示or。</p><p>必选项：以下三个常数中必须指定一个，且仅允许指定一个。</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">O_RDONLY</code> 只读打开</p></li><li><p><code class="literal">O_WRONLY</code> 只写打开</p></li><li><p><code class="literal">O_RDWR</code> 可读可写打开</p></li></ul></div><p>以下可选项可以同时指定0个或多个，和必选项按位或起来作为<code class="literal">flags</code>参数。可选项有很多，这里只介绍一部分，其它选项可参考<code class="literal">open(2)</code>的Man Page：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">O_APPEND</code> 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容。</p></li><li><p><code class="literal">O_CREAT</code> 若此文件不存在则创建它。使用此选项时需要提供第三个参数<code class="literal">mode</code>，表示该文件的访问权限。</p></li><li><p><code class="literal">O_EXCL</code> 如果同时指定了<code class="literal">O_CREAT</code>，并且文件已存在，则出错返回。</p></li><li><p><code class="literal">O_TRUNC</code> 如果文件已存在，并且以只写或可读可写方式打开，则将其长度截断（Truncate）<a id="id2851609" class="indexterm"></a>为0字节。</p></li><li><p><code class="literal">O_NONBLOCK</code> 对于设备文件，以<code class="literal">O_NONBLOCK</code>方式打开可以做非阻塞I/O（Nonblock I/O）<a id="id2851635" class="indexterm"></a>，非阻塞I/O在下一节详细讲解。</p></li></ul></div><p>注意<code class="literal">open</code>函数与C标准I/O库的<code class="literal">fopen</code>函数有些细微的区别：</p><div class="itemizedlist"><ul type="disc"><li><p>以可写的方式<code class="literal">fopen</code>一个文件时，如果文件不存在会自动创建，而<code class="literal">open</code>一个文件时必须明确指定<code class="literal">O_CREAT</code>才会创建文件，否则文件不存在就出错返回。</p></li><li><p>以<code class="literal">w</code>或<code class="literal">w+</code>方式<code class="literal">fopen</code>一个文件时，如果文件已存在就截断为0字节，而<code class="literal">open</code>一个文件时必须明确指定<code class="literal">O_TRUNC</code>才会截断文件，否则直接在原来的数据上改写。</p></li></ul></div><p>第三个参数<code class="literal">mode</code>指定文件权限，可以用八进制数表示，比如0644表示<code class="literal">-rw-r--r--</code>，也可以用<code class="literal">S_IRUSR</code>、<code class="literal">S_IWUSR</code>等宏定义按位或起来表示，详见<code class="literal">open(2)</code>的Man Page。要注意的是，文件权限由<code class="literal">open</code>的<code class="literal">mode</code>参数和当前进程的<code class="literal">umask</code>掩码共同决定。</p><p>补充说明一下Shell的<code class="literal">umask</code>命令。Shell进程的<code class="literal">umask</code>掩码可以用<code class="literal">umask</code>命令查看：</p><pre class="screen">$ umask
0022</pre><p>用<code class="literal">touch</code>命令创建一个文件时，创建权限是0666，而<code class="literal">touch</code>进程继承了Shell进程的<code class="literal">umask</code>掩码，所以最终的文件权限是0666&amp;~022=0644。</p><pre class="screen">$ touch file123
$ ls -l file123
-rw-r--r-- 1 akaedu akaedu 0 2009-03-08 15:07 file123</pre><p>同样道理，用<code class="literal">gcc</code>编译生成一个可执行文件时，创建权限是0777，而最终的文件权限是0777&amp;~022=0755。</p><pre class="screen">$ gcc main.c
$ ls -l a.out
-rwxr-xr-x 1 akaedu akaedu 6483 2009-03-08 15:07 a.out</pre><p>我们看到的都是被<code class="literal">umask</code>掩码修改之后的权限，那么如何证明<code class="literal">touch</code>或<code class="literal">gcc</code>创建文件的权限本来应该是0666和0777呢？我们可以把Shell进程的<code class="literal">umask</code>改成0，再重复上述实验：</p><pre class="screen">$ umask 0
$ touch file123
$ rm file123 a.out
$ touch file123
$ ls -l file123
-rw-rw-rw- 1 akaedu akaedu 0 2009-03-08 15:09 file123
$ gcc main.c
$ ls -l a.out
-rwxrwxrwx 1 akaedu akaedu 6483 2009-03-08 15:09 a.out</pre><p>现在我们自己写一个程序，在其中调用<code class="literal">open("somefile", O_WRONLY|O_CREAT, 0664);</code>创建文件，然后在Shell中运行并查看结果：</p><pre class="screen">$ umask 022
$ ./a.out
$ ls -l somefile
-rw-r--r-- 1 akaedu akaedu 6483 2009-03-08 15:11 somefile</pre><p>不出所料，文件<code class="literal">somefile</code>的权限是0664&amp;~022=0644。有几个问题现在我没有解释：为什么被Shell启动的进程可以继承Shell进程的<code class="literal">umask</code>掩码？为什么<code class="literal">umask</code>命令可以读写Shell进程的<code class="literal">umask</code>掩码？这些问题将在<a class="xref" href="ch30s01.html#process.intro">第 1 节 “引言”</a>解释。</p><p><code class="literal">close</code>函数关闭一个已打开的文件：</p><pre class="programlisting">#include &lt;unistd.h&gt;

int close(int fd);
返回值：成功返回0，出错返回-1并设置errno</pre><p>参数<code class="literal">fd</code>是要关闭的文件描述符。需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用<code class="literal">close</code>关闭，所以即使用户程序不调用<code class="literal">close</code>，在终止时内核也会自动关闭它打开的所有文件。但是对于一个长年累月运行的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</p><p>由<code class="literal">open</code>返回的文件描述符一定是该进程尚未使用的最小描述符。由于程序启动时自动打开文件描述符0、1、2，因此第一次调用<code class="literal">open</code>打开文件通常会返回描述符3，再调用<code class="literal">open</code>就会返回4。可以利用这一点在标准输入、标准输出或标准错误输出上打开一个新文件，实现重定向的功能。例如，首先调用<code class="literal">close</code>关闭文件描述符1，然后调用<code class="literal">open</code>打开一个常规文件，则一定会返回文件描述符1，这时候标准输出就不再是终端，而是一个常规文件了，再调用<code class="literal">printf</code>就不会打印到屏幕上，而是写到这个文件中了。后面要讲的<code class="literal">dup2</code>函数提供了另外一种办法在指定的文件描述符上打开文件。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2852046"></a>习题</h3></div></div></div><p>1、在系统头文件中查找<code class="literal">flags</code>和<code class="literal">mode</code>参数用到的这些宏定义的值是多少。把这些宏定义按位或起来是什么效果？为什么必选项只能选一个而可选项可以选多个？</p><p>2、请按照下述要求分别写出相应的<code class="literal">open</code>调用。</p><div class="itemizedlist"><ul type="disc"><li><p>打开文件<code class="literal">/home/akae.txt</code>用于写操作，以追加方式打开</p></li><li><p>打开文件<code class="literal">/home/akae.txt</code>用于写操作，如果该文件不存在则创建它</p></li><li><p>打开文件<code class="literal">/home/akae.txt</code>用于写操作，如果该文件已存在则截断为0字节，如果该文件不存在则创建它</p></li><li><p>打开文件<code class="literal">/home/akae.txt</code>用于写操作，如果该文件已存在则报错退出，如果该文件不存在则创建它</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch28s02.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch28.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch28s04.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">2. C标准I/O库函数与Unbuffered I/O函数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 4. read/write</td></tr></table></div></body></html>
