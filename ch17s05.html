<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5. Memory Hierarchy</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch17.html" title="第 17 章 计算机体系结构基础" /><link rel="prev" href="ch17s04.html" title="4. MMU" /><link rel="next" href="ch18.html" title="第 18 章 x86汇编程序基础" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Memory Hierarchy</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch17s04.html">上一页</a> </td><th width="60%" align="center">第 17 章 计算机体系结构基础</th><td width="20%" align="right"> <a accesskey="n" href="ch18.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2767397"></a>5. Memory Hierarchy</h2></div></div></div><p>硬盘、内存、CPU寄存器，还有本节要讲的Cache，这些都是存储器，计算机为什么要有这么多种存储器呢？这些存储器各自有什么特点？这是本节要讨论的问题。</p><p>由于硬件技术的限制，我们可以制造出容量很小但很快的存储器，也可以制造出容量很大但很慢的存储器，但不可能两边的好处都占着，不可能制造出访问速度又快容量又大的存储器。因此，现代计算机都把存储器分成若干级，称为Memory Hierarchy<a id="id2767425" class="indexterm"></a>，按照离CPU由近到远的顺序依次是CPU寄存器、Cache、内存、硬盘，越靠近CPU的存储器容量越小但访问速度越快，下图给出了各种存储器的容量和访问速度的典型值。</p><div class="figure"><a id="id2767436"></a><p class="title"><b>图 17.8. Memory Hierarchy</b></p><div class="figure-contents"><div><img src="images/arch.memhie.png" alt="Memory Hierarchy" /></div></div></div><br class="figure-break" /><div class="table"><a id="id2767450"></a><p class="title"><b>表 17.1. Memory Hierarchy</b></p><div class="table-contents"><table summary="Memory Hierarchy" border="1"><colgroup><col /><col /><col /><col /><col /><col /></colgroup><thead><tr><th>存储器类型</th><th>位于哪里</th><th>存储容量</th><th>半导体工艺</th><th>访问时间</th><th>如何访问</th></tr></thead><tbody><tr><td>CPU寄存器</td><td>位于CPU执行单元中。</td><td>CPU寄存器通常只有几个到几十个，每个寄存器的容量取决于CPU的字长，所以一共只有几十到几百字节。</td><td>“<span class="quote">寄存器</span>”这个名字就是一种数字电路的名字，它由一组触发器（Flip-flop）<a id="id2767501" class="indexterm"></a>组成，每个触发器保存一个Bit的数据，可以做存取和移位等操作。计算机掉电时寄存器中保存的数据会丢失。</td><td>寄存器是访问速度最快的存储器，典型的访问时间是几纳秒。</td><td>使用哪个寄存器，如何使用寄存器，这些都是由指令决定的。</td></tr><tr><td>Cache<a id="id2767524" class="indexterm"></a></td><td>和MMU一样位于CPU核中。</td><td>Cache通常分为几级，最典型的是如上图所示的两级Cache，一级Cache更靠近CPU执行单元，二级Cache更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB。</td><td>Cache和内存都是由RAM（Random Access Memory）<a id="id2767548" class="indexterm"></a>组成的，可以根据地址随机访问，计算机掉电时RAM中保存的数据会丢失。不同的是，Cache通常由SRAM（Static RAM，静态RAM）<a id="id2767558" class="indexterm"></a>组成，而内存通常由DRAM（Dynamic RAM，动态RAM）<a id="id2767566" class="indexterm"></a>组成。DRAM电路比SRAM简单，存储容量可以做得更大，但DRAM的访问速度比SRAM慢。</td><td>典型的访问时间是几十纳秒。</td><td>Cache缓存最近访问过的内存数据，由于Cache的访问速度是内存的几十倍，所以有效利用Cache可以大大提高计算机的整体性能。一级Cache是这样工作的：CPU执行单元要访问内存时首先发出VA，Cache利用VA查找相应的数据有没有被缓存，如果Cache中有就不需要访问物理内存了，如果是读操作就直接将Cache中的数据传给CPU寄存器，如果是写操作就直接改写到Cache中；如果Cache没有缓存该数据，就去物理内存中取数据，但并不是要哪个字节就取哪个字节，而是把相邻的几十个字节都取上来缓存着，以备下次用到，这称为一个Cache Line<a id="id2767606" class="indexterm"></a>，典型的Cache Line大小是32~256字节。如果计算机还配置了二级缓存，则在访问物理内存之前先用PA去二级缓存中查找。一级缓存是用VA寻址的，二级缓存是用PA寻址的，这是它们的区别。Cache所做的工作是由硬件自动完成的，而不是像寄存器一样由指令决定先做什么后做什么。</td></tr><tr><td>内存</td><td>位于CPU外的芯片，与CPU通过地址和数据总线相连。</td><td>典型的存储容量是几百MB到几GB。</td><td>由DRAM组成，详见上面关于Cache的说明。</td><td>典型的访问时间是几百纳秒。</td><td>内存是通过地址来访问的，在启用MMU的情况下，程序指令中的地址是VA，而访问内存用的是PA，它们之间的映射关系由操作系统维护。</td></tr><tr><td>硬盘</td><td>位于设备总线上，并不直接和CPU相连，CPU通过设备总线的控制器访问硬盘。</td><td>典型的存储容量是几百GB到几TB。</td><td>硬盘由磁性介质和磁头组成，访问硬盘时存在机械运动，磁头要移动，磁性介质要旋转，机械运动的速度很难提高到电子的速度，所以访问速度很受限制。保存在硬盘上的数据掉电后不会丢失。</td><td>典型的访问时间是几毫秒，是寄存器访问时间的10<sup>6</sup>倍。</td><td>由驱动程序操作设备总线控制器去访问。由于硬盘的访问速度较慢，操作系统通常一次从硬盘上读几个页面到内存中缓存起来，如果这几个页面后来都被程序访问到了，那么这一次读硬盘的时间就可以分摊（Amortize）<a id="id2767689" class="indexterm"></a>给程序的多次访问了。</td></tr></tbody></table></div></div><br class="table-break" /><p>对这个表格总结如下。</p><div class="itemizedlist"><ul type="disc"><li><p>寄存器、Cache和内存中的数据都是掉电丢失的，这称为易失性存储器（Volatile Memory）<a id="id2767713" class="indexterm"></a>，与之相对的，硬盘是一种非易失性存储器（Non-volatile Memory）<a id="id2767722" class="indexterm"></a>。</p></li><li><p>除了访问寄存器由程序指令直接控制之外，访问其它存储器都不是由指令直接控制的，有些是硬件自动完成的，有些是操作系统配合硬件完成的。</p></li><li><p>Cache从内存取数据时会预取一个Cache Line缓存起来，操作系统从硬盘读数据时会预读几个页面缓存起来，都是希望这些数据以后会被程序访问到。大多数程序的行为都具有局部性（Locality）<a id="id2767749" class="indexterm"></a>的特点：它们会花费大量的时间反复执行一小段代码（例如循环），或者反复访问一个很小的地址范围中的数据（例如访问一个数组）。所以预读缓存的办法是很有效的：CPU取一条指令，我把和它相邻的指令也都缓存起来，CPU很可能马上就会取到；CPU访问一个数据，我把和它相邻的数据也都缓存起来，CPU很可能马上就会访问到。设想有两台计算机，一台有256KB的Cache，另一台没有Cache，两台计算机的内存都是512MB的，硬盘都是100GB的，虽然多出来256KB的Cache与内存、硬盘的容量相比微不足道，但访问Cache比访问内存、硬盘快几个数量级，由于局部性原理，CPU大部分时间是在和Cache打交道，有Cache的计算机明显会快很多。高速存储器的容量只能做得很小，却能显著提升计算机的性能，这就是Memory Hierarchy的意义所在。</p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch17s04.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch17.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch18.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">4. MMU </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 18 章 x86汇编程序基础</td></tr></table></div></body></html>
