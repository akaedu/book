<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. 变量</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch22.html" title="第 22 章 Makefile基础" /><link rel="prev" href="ch22s02.html" title="2. 隐含规则和模式规则" /><link rel="next" href="ch22s04.html" title="4. 自动处理头文件的依赖关系" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. 变量</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch22s02.html">上一页</a> </td><th width="60%" align="center">第 22 章 Makefile基础</th><td width="20%" align="right"> <a accesskey="n" href="ch22s04.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2804672"></a>3. 变量</h2></div></div></div><p>这一节我们详细看看Makefile中关于变量的语法规则。先看一个简单的例子：</p><pre class="programlisting">foo = $(bar) 
bar = Huh? 

all: 
	@echo $(foo)</pre><p>我们执行<code class="literal">make</code>将会打出<code class="literal">Huh?</code>。当<code class="literal">make</code>读到<code class="literal">foo = $(bar)</code>时，确定<code class="literal">foo</code>的值是<code class="literal">$(bar)</code>，但并不立即展开<code class="literal">$(bar)</code>，然后读到<code class="literal">bar = Huh?</code>，确定<code class="literal">bar</code>的值是<code class="literal">Huh?</code>，然后在执行规则<code class="literal">all:</code>的命令列表时才需要展开<code class="literal">$(foo)</code>，得到<code class="literal">$(bar)</code>，再展开<code class="literal">$(bar)</code>，得到<code class="literal">Huh?</code>。因此，虽然<code class="literal">bar</code>的定义写在<code class="literal">foo</code>之后，<code class="literal">$(foo)</code>展开还是能够取到<code class="literal">$(bar)</code>的值。</p><p>这种特性有好处也有坏处。好处是我们可以把变量的值推迟到后面定义，例如：</p><pre class="programlisting">main.o: main.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt;

CC = gcc
CFLAGS = -O -g
CPPFLAGS = -Iinclude</pre><p>编译命令可以展开成<code class="literal">gcc -O -g -Iinclude -c main.c</code>。通常把<code class="literal">CFLAGS</code>定义成一些编译选项，例如<code class="literal">-O</code>、<code class="literal">-g</code>等，而把<code class="literal">CPPFLAGS</code>定义成一些预处理选项，例如<code class="literal">-D</code>、<code class="literal">-I</code>等。用<code class="literal">=</code>号定义变量的延迟展开特性也有坏处，就是有可能写出无穷递归的定义，例如<code class="literal">CFLAGS = $(CFLAGS) -O</code>，或者：</p><pre class="programlisting">A = $(B)
B = $(A)</pre><p>当然，<code class="literal">make</code>有能力检测出这样的错误而不会陷入死循环。有时候我们希望<code class="literal">make</code>在遇到变量定义时立即展开，可以用<code class="literal">:=</code>运算符，例如：</p><pre class="programlisting">x := foo
y := $(x) bar

all: 
	@echo "-$(y)-"</pre><p>当<code class="literal">make</code>读到<code class="literal">y := $(x) bar</code>定义时，立即把<code class="literal">$(x)</code>展开，使变量<code class="literal">y</code>的取值是<code class="literal">foo bar</code>，如果把这两行颠倒过来：</p><pre class="programlisting">y := $(x) bar
x := foo</pre><p>那么当<code class="literal">make</code>读到<code class="literal">y := $(x) bar</code>时，<code class="literal">x</code>还没有定义，展开为空值，所以<code class="literal">y</code>的取值是<code class="literal">␣bar</code>，注意<code class="literal">bar</code>前面有个空格。一个变量的定义从<code class="literal">=</code>后面的第一个非空白字符开始（从<code class="literal">$(x)</code>的<code class="literal">$</code>开始），包括后面的所有字符，直到注释或换行之前结束。如果要定义一个变量的值是一个空格，可以这样：</p><pre class="programlisting">nullstring := 
space := $(nullstring) # end of the line</pre><p><code class="literal">nullstring</code>的值为空，<code class="literal">space</code>的值是一个空格，后面写个注释是为了增加可读性，如果不写注释就换行，则很难看出<code class="literal">$(nullstring)</code>后面有个空格。</p><p>还有一个比较有用的赋值运算符是<code class="literal">?=</code>，例如<code class="literal">foo ?= $(bar)</code>的意思是：如果<code class="literal">foo</code>没有定义过，那么<code class="literal">?=</code>相当于<code class="literal">=</code>，定义<code class="literal">foo</code>的值是<code class="literal">$(bar)</code>，但不立即展开；如果先前已经定义了<code class="literal">foo</code>，则什么也不做，不会给<code class="literal">foo</code>重新赋值。</p><p><code class="literal">+=</code>运算符可以给变量追加值，例如：</p><pre class="programlisting">objects = main.o
objects += $(foo)
foo = foo.o bar.o</pre><p><code class="literal">object</code>是用<code class="literal">=</code>定义的，<code class="literal">+=</code>仍然保持<code class="literal">=</code>的特性，<code class="literal">objects</code>的值是<code class="literal">main.o $(foo)</code>（注意<code class="literal">$(foo)</code>前面自动添一个空格），但不立即展开，等到后面需要展开<code class="literal">$(objects)</code>时会展开成<code class="literal">main.o foo.o bar.o</code>。</p><p>再比如：</p><pre class="programlisting">objects := main.o
objects += $(foo)
foo = foo.o bar.o</pre><p><code class="literal">object</code>是用<code class="literal">:=</code>定义的，<code class="literal">+=</code>保持<code class="literal">:=</code>的特性，<code class="literal">objects</code>的值是<code class="literal">main.o $(foo)</code>，立即展开得到<code class="literal">main.o </code>（这时<code class="literal">foo</code>还没定义），注意<code class="literal">main.o</code>后面的空格仍保留。</p><p>如果变量还没有定义过就直接用<code class="literal">+=</code>赋值，那么<code class="literal">+=</code>相当于<code class="literal">=</code>。</p><p>上一节我们用到了特殊变量<code class="literal">$@</code>和<code class="literal">$&lt;</code>，这两个变量的特点是不需要给它们赋值，在不同的上下文中它们自动取不同的值。常用的特殊变量有：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">$@</code>，表示规则中的目标。</p></li><li><p><code class="literal">$&lt;</code>，表示规则中的第一个条件。</p></li><li><p><code class="literal">$?</code>，表示规则中所有比目标新的条件，组成一个列表，以空格分隔。</p></li><li><p><code class="literal">$^</code>，表示规则中的所有条件，组成一个列表，以空格分隔。</p></li></ul></div><p>例如前面写过的这条规则：</p><pre class="programlisting">main: main.o stack.o maze.o
	gcc main.o stack.o maze.o -o main</pre><p>可以改写成：</p><pre class="programlisting">main: main.o stack.o maze.o
	gcc $^ -o $@</pre><p>这样即使以后又往条件里添加了新的目标文件，编译命令也不需要修改，减少了出错的可能。</p><p><code class="literal">$?</code>变量也很有用，有时候希望只对更新过的条件进行操作，例如有一个库文件<code class="literal">libsome.a</code>依赖于几个目标文件：</p><pre class="programlisting">libsome.a: foo.o bar.o lose.o win.o 
	ar r libsome.a $?
	ranlib libsome.a</pre><p>这样，只有更新过的目标文件才需要重新打包到<code class="literal">libsome.a</code>中，没更新过的目标文件原本已经在<code class="literal">libsome.a</code>中了，不必重新打包。</p><p>在上一节我们看到<code class="literal">make</code>的隐含规则数据库中用到了很多变量，有些变量没有定义（例如<code class="literal">CFLAGS</code>），有些变量定义了缺省值（例如<code class="literal">CC</code>），我们写Makefile时可以重新定义这些变量的值，也可以在缺省值的基础上追加。以下列举一些常用的变量，请读者体会其中的规律。</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">AR</code></span></dt><dd><p>静态库打包命令的名字，缺省值是<code class="literal">ar</code>。</p></dd><dt><span class="term"><code class="literal">ARFLAGS</code></span></dt><dd><p>静态库打包命令的选项，缺省值是<code class="literal">rv</code>。</p></dd><dt><span class="term"><code class="literal">AS</code></span></dt><dd><p>汇编器的名字，缺省值是<code class="literal">as</code>。</p></dd><dt><span class="term"><code class="literal">ASFLAGS</code></span></dt><dd><p>汇编器的选项，没有定义。</p></dd><dt><span class="term">CC</span></dt><dd><p>C编译器的名字，缺省值是<code class="literal">cc</code>。</p></dd><dt><span class="term">CFLAGS</span></dt><dd><p>C编译器的选项，没有定义。</p></dd><dt><span class="term">CXX</span></dt><dd><p>C++编译器的名字，缺省值是<code class="literal">g++</code>。</p></dd><dt><span class="term">CXXFLAGS</span></dt><dd><p>C++编译器的选项，没有定义。</p></dd><dt><span class="term">CPP</span></dt><dd><p>C预处理器的名字，缺省值是<code class="literal">$(CC) -E</code>。</p></dd><dt><span class="term">CPPFLAGS</span></dt><dd><p>C预处理器的选项，没有定义。</p></dd><dt><span class="term">LD</span></dt><dd><p>链接器的名字，缺省值是<code class="literal">ld</code>。</p></dd><dt><span class="term">LDFLAGS</span></dt><dd><p>链接器的选项，没有定义。</p></dd><dt><span class="term">TARGET_ARCH</span></dt><dd><p>和目标平台相关的命令行选项，没有定义。</p></dd><dt><span class="term">OUTPUT_OPTION</span></dt><dd><p>输出的命令行选项，缺省值是<code class="literal">-o $@</code>。</p></dd><dt><span class="term">LINK.o</span></dt><dd><p>把<code class="literal">.o</code>文件链接在一起的命令行，缺省值是<code class="literal">$(CC) $(LDFLAGS) $(TARGET_ARCH)</code>。</p></dd><dt><span class="term">LINK.c</span></dt><dd><p>把<code class="literal">.c</code>文件链接在一起的命令行，缺省值是<code class="literal">$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)</code>。</p></dd><dt><span class="term">LINK.cc</span></dt><dd><p>把<code class="literal">.cc</code>文件（C++源文件）链接在一起的命令行，缺省值是<code class="literal">$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)</code>。</p></dd><dt><span class="term">COMPILE.c</span></dt><dd><p>编译<code class="literal">.c</code>文件的命令行，缺省值是<code class="literal">$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</code>。</p></dd><dt><span class="term">COMPILE.cc</span></dt><dd><p>编译<code class="literal">.cc</code>文件的命令行，缺省值是<code class="literal">$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</code>。</p></dd><dt><span class="term">RM</span></dt><dd><p>删除命令的名字，缺省值是<code class="literal">rm -f</code>。</p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch22s02.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch22.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch22s04.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">2. 隐含规则和模式规则 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 4. 自动处理头文件的依赖关系</td></tr></table></div></body></html>
