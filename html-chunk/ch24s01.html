<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 本章的预备知识</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch24.html" title="第 24 章 函数接口" /><link rel="prev" href="ch24.html" title="第 24 章 函数接口" /><link rel="next" href="ch24s02.html" title="2. 传入参数与传出参数" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 本章的预备知识</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch24.html">上一页</a> </td><th width="60%" align="center">第 24 章 函数接口</th><td width="20%" align="right"> <a accesskey="n" href="ch24s02.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2818430"></a>1. 本章的预备知识</h2></div></div></div><p>这一节介绍本章的范例代码要用的几个C标准库函数。我们先体会一下这几个函数的接口是怎么设计的，Man Page是怎么写的。其它常用的C标准库函数将在下一章介绍。</p><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2819066"></a>1.1. <code class="literal">strcpy</code>与<code class="literal">strncpy</code></h3></div></div></div><p>从现在开始我们要用到很多库函数，在学习每个库函数时一定要看Man Page。Man Page随时都在我们手边，想查什么只要敲一个命令就行，然而很多初学者就是不喜欢看Man Page，宁可满世界去查书、查资料，也不愿意看Man Page。据我分析原因有三：</p><div class="orderedlist"><ol type="1"><li><p>英文不好。那还是先学好了英文再学编程吧，否则即使你把这本书都学透了也一样无法胜任开发工作，因为你没有进一步学习的能力。</p></li><li><p>Man Page的语言不够友好。Man Page不像本书这样由浅入深地讲解，而是平铺直叙，不过看习惯了就好了，每个Man Page都不长，多看几遍自然可以抓住重点，理清头绪。本节分析一个例子，帮助读者把握Man Page的语言特点。</p></li><li><p>Man Page通常没有例子。描述一个函数怎么用，一靠接口，二靠文档，而不是靠例子。函数的用法无非是本章所总结的几种模式，只要把本章学透了，你就不需要每个函数都得有个例子教你怎么用了。</p></li></ol></div><p>总之，Man Page是一定要看的，一开始看不懂硬着头皮也要看，为了鼓励读者看Man Page，本书不会像<a class="xref" href="bi01.html#bibli.kr" title="The C Programming Language">[<abbr class="abbrev">K&amp;R</abbr>]</a>那样把库函数总结成一个附录附在书后面。现在我们来分析<code class="literal">strcpy(3)</code>。</p><div class="figure"><a id="id2819154"></a><p class="title"><b>图 24.1. <code class="literal">strcpy(3)</code></b></p><div class="figure-contents"><div><img src="images/interface.synopsis.png" alt="strcpy(3)" /></div></div></div><br class="figure-break" /><p>这个Man Page描述了两个函数，<code class="literal">strcpy</code>和<code class="literal">strncpy</code>，敲命令<code class="literal">man strcpy</code>或者<code class="literal">man strncpy</code>都可以看到这个Man Page。这两个函数的作用是把一个字符串拷贝给另一个字符串。<span class="emphasis"><em>SYNOPSIS</em></span>部分给出了这两个函数的原型，以及要用这些函数需要包含哪些头文件。参数<code class="literal">dest</code>、<code class="literal">src</code>和<code class="literal">n</code>都加了下划线，有时候并不想从头到尾阅读整个Man Page，而是想查一下某个参数的含义，通过下划线和参数名就能很快找到你关心的部分。</p><p><code class="literal">dest</code>表示Destination，<code class="literal">src</code>表示Source，看名字就能猜到是把<code class="literal">src</code>所指向的字符串拷贝到<code class="literal">dest</code>所指向的内存空间。这一点从两个参数的类型也能看出来，<code class="literal">dest</code>是<code class="literal">char *</code>型的，而<code class="literal">src</code>是<code class="literal">const char *</code>型的，说明<code class="literal">src</code>所指向的内存空间在函数中只能读不能改写，而<code class="literal">dest</code>所指向的内存空间在函数中是要改写的，显然改写的目的是当函数返回后调用者可以读取改写的结果。因此可以猜到<code class="literal">strcpy</code>函数是这样用的：</p><pre class="programlisting">char buf[10];
strcpy(buf, "hello");
printf(buf);</pre><p>至于<code class="literal">strncpy</code>的参数<code class="literal">n</code>是干什么用的，单从函数接口猜不出来，就需要看下面的文档。</p><div class="figure"><a id="id2819320"></a><p class="title"><b>图 24.2. <code class="literal">strcpy(3)</code></b></p><div class="figure-contents"><div><img src="images/interface.description.png" alt="strcpy(3)" /></div></div></div><br class="figure-break" /><p>在文档中强调了<code class="literal">strcpy</code>在拷贝字符串时会把结尾的<code class="literal">'\0'</code>也拷到<code class="literal">dest</code>中，因此保证了<code class="literal">dest</code>中是以<code class="literal">'\0'</code>结尾的字符串。但另外一个要注意的问题是，<code class="literal">strcpy</code>只知道<code class="literal">src</code>字符串的首地址，不知道长度，它会一直拷贝到<code class="literal">'\0'</code>为止，所以<code class="literal">dest</code>所指向的内存空间要足够大，否则有可能写越界，例如：</p><pre class="programlisting">char buf[10];
strcpy(buf, "hello world");</pre><p>如果没有保证<code class="literal">src</code>所指向的内存空间以<code class="literal">'\0'</code>结尾，也有可能读越界，例如：</p><pre class="programlisting">char buf[10] = "abcdefghij", str[4] = "hell";
strcpy(buf, str);</pre><p>因为<code class="literal">strcpy</code>函数的实现者通过函数接口无法得知<code class="literal">src</code>字符串的长度和<code class="literal">dest</code>内存空间的大小，所以“<span class="quote">确保不会写越界</span>”应该是调用者的责任，调用者提供的<code class="literal">dest</code>参数应该指向足够大的内存空间，“<span class="quote">确保不会读越界</span>”也是调用者的责任，调用者提供的<code class="literal">src</code>参数指向的内存应该确保以<code class="literal">'\0'</code>结尾。</p><p>此外，文档中还强调了<code class="literal">src</code>和<code class="literal">dest</code>所指向的内存空间不能有重叠。凡是有指针参数的C标准库函数基本上都有这条要求，每个指针参数所指向的内存空间互不重叠，例如这样调用是不允许的：</p><pre class="programlisting">char buf[10] = "hello";
strcpy(buf, buf+1);</pre><p><code class="literal">strncpy</code>的参数<code class="literal">n</code>指定最多从<code class="literal">src</code>中拷贝<code class="literal">n</code>个字节到<code class="literal">dest</code>中，换句话说，如果拷贝到<code class="literal">'\0'</code>就结束，如果拷贝到<code class="literal">n</code>个字节还没有碰到<code class="literal">'\0'</code>，那么也结束，调用者负责提供适当的<code class="literal">n</code>值，以确保读写不会越界，比如让<code class="literal">n</code>的值等于<code class="literal">dest</code>所指向的内存空间的大小：</p><pre class="programlisting">char buf[10];
strncpy(buf, "hello world", sizeof(buf));</pre><p>然而这意味着什么呢？文档中特别用了<span class="emphasis"><em>Warning</em></span>指出，这意味着<code class="literal">dest</code>有可能不是以<code class="literal">'\0'</code>结尾的。例如上面的调用，虽然把<code class="literal">"hello world"</code>截断到10个字符拷贝至<code class="literal">buf</code>中，但<code class="literal">buf</code>不是以<code class="literal">'\0'</code>结尾的，如果再<code class="literal">printf(buf)</code>就会读越界。如果你需要确保<code class="literal">dest</code>以<code class="literal">'\0'</code>结束，可以这么调用：</p><pre class="programlisting">char buf[10];
strncpy(buf, "hello world", sizeof(buf));
buf[sizeof(buf)-1] = '\0';</pre><p><code class="literal">strncpy</code>还有一个特性，如果<code class="literal">src</code>字符串全部拷完了不足<code class="literal">n</code>个字节，那么还差多少个字节就补多少个<code class="literal">'\0'</code>，但是正如上面所述，这并不保证<code class="literal">dest</code>一定以<code class="literal">'\0'</code>结束，当<code class="literal">src</code>字符串的长度大于<code class="literal">n</code>时，不但不补多余的<code class="literal">'\0'</code>，连字符串的结尾<code class="literal">'\0'</code>也不拷贝。<code class="literal">strcpy(3)</code>的文档已经相当友好了，为了帮助理解，还给出一个<code class="literal">strncpy</code>的简单实现。</p><div class="figure"><a id="id2819716"></a><p class="title"><b>图 24.3. <code class="literal">strcpy(3)</code></b></p><div class="figure-contents"><div><img src="images/interface.return.png" alt="strcpy(3)" /></div></div></div><br class="figure-break" /><p>函数的Man Page都有一部分专门讲返回值的。这两个函数的返回值都是<code class="literal">dest</code>指针。可是为什么要返回<code class="literal">dest</code>指针呢？<code class="literal">dest</code>指针本来就是调用者传过去的，再返回一遍<code class="literal">dest</code>指针并没有提供任何有用的信息。之所以这么规定是为了把函数调用当作一个指针类型的表达式使用，比如<code class="literal">printf("%s\n", strcpy(buf, "hello"))</code>，一举两得，如果<code class="literal">strcpy</code>的返回值是<code class="literal">void</code>就没有这么方便了。</p><p><span class="emphasis"><em>CONFORMING TO</em></span>部分描述了这个函数是遵照哪些标准实现的。<code class="literal">strcpy</code>和<code class="literal">strncpy</code>是C标准库函数，当然遵照C99标准。以后我们还会看到<code class="literal">libc</code>中有些函数属于POSIX标准但并不属于C标准，例如<code class="literal">write(2)</code>。</p><p><span class="emphasis"><em>NOTES</em></span>部分给出一些提示信息。这里指出如何确保<code class="literal">strncpy</code>的<code class="literal">dest</code>以<code class="literal">'\0'</code>结尾，和我们上面给出的代码类似，但由于<code class="literal">n</code>是个变量，在执行<code class="literal">buf[n - 1]= '\0';</code>之前先检查一下<code class="literal">n</code>是否大于0，如果<code class="literal">n</code>不大于0，<code class="literal">buf[n - 1]</code>就访问越界了，所以要避免。</p><div class="figure"><a id="id2819873"></a><p class="title"><b>图 24.4. <code class="literal">strcpy(3)</code></b></p><div class="figure-contents"><div><img src="images/interface.bugs.png" alt="strcpy(3)" /></div></div></div><br class="figure-break" /><p><span class="emphasis"><em>BUGS</em></span>部分说明了使用这些函数可能引起的Bug，这部分一定要仔细看。用<code class="literal">strcpy</code>比用<code class="literal">strncpy</code>更加不安全，如果在调用<code class="literal">strcpy</code>之前不仔细检查<code class="literal">src</code>字符串的长度就有可能写越界，这是一个很常见的错误，例如：</p><pre class="programlisting">void foo(char *str)
{
	char buf[10];
	strcpy(buf, str);
	...
}</pre><p><code class="literal">str</code>所指向的字符串有可能超过10个字符而导致写越界，在<a class="xref" href="ch10s04.html#gdb.segfault">第 4 节 “段错误”</a>我们看到过，这种写越界可能当时不出错，而在函数返回时出现段错误，原因是写越界覆盖了保存在栈帧上的返回地址，函数返回时跳转到非法地址，因而出错。像<code class="literal">buf</code>这种由调用者分配并传给函数读或写的一段内存通常称为缓冲区（Buffer）<a id="id2819951" class="indexterm"></a>，缓冲区写越界的错误称为缓冲区溢出（Buffer Overflow）<a id="id2819959" class="indexterm"></a>。如果只是出现段错误那还不算严重，更严重的是缓冲区溢出Bug经常被恶意用户利用，使函数返回时跳转到一个事先设好的地址，执行事先设好的指令，如果设计得巧妙甚至可以启动一个Shell，然后随心所欲执行任何命令，可想而知，如果一个用<code class="literal">root</code>权限执行的程序存在这样的Bug，被攻陷了，后果将很严重。至于怎样巧妙设计和攻陷一个有缓冲区溢出Bug的程序，有兴趣的读者可以参考<a class="xref" href="bi01.html#bibli.smashstack" title="Smashing The Stack For Fun And Profit，网上到处都可以搜到这篇文章">[<abbr class="abbrev">SmashStack</abbr>]</a>。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2819997"></a>习题</h4></div></div></div><p>1、自己实现一个<code class="literal">strcpy</code>函数，尽可能简洁，按照本书的编码风格你能用三行代码写出函数体吗？</p><p>2、编一个函数，输入一个字符串，要求做一个新字符串，把其中所有的一个或多个连续的空白字符都压缩为一个空格。这里所说的空白包括空格、'\t'、'\n'、'\r'。例如原来的字符串是：</p><pre class="programlisting">This Content hoho       is ok
        ok?

        file system
uttered words   ok ok      ?
end.</pre><p>压缩了空白之后就是：</p><pre class="programlisting">This Content hoho is ok ok? file system uttered words ok ok ? end.</pre><p>实现该功能的函数接口要求符合下述规范：</p><pre class="programlisting">char *shrink_space(char *dest, const char *src, size_t n);</pre><p>各项参数和返回值的含义和<code class="literal">strncpy</code>类似。完成之后，为自己实现的函数写一个Man Page。</p></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2820062"></a>1.2. <code class="literal">malloc</code>与<code class="literal">free</code></h3></div></div></div><p>程序中需要动态分配一块内存时怎么办呢？可以像上一节那样定义一个缓冲区数组。这种方法不够灵活，C89要求定义的数组是固定长度的，而程序往往在运行时才知道要动态分配多大的内存，例如：</p><pre class="programlisting">void foo(char *str, int n)
{
	char buf[?];
	strncpy(buf, str, n);
	...
}</pre><p><code class="literal">n</code>是由参数传进来的，事先不知道是多少，那么<code class="literal">buf</code>该定义多大呢？在<a class="xref" href="ch08s01.html#array.intro">第 1 节 “数组的基本概念”</a>讲过C99引入VLA特性，可以定义<code class="literal">char buf[n+1] = {};</code>，这样可确保<code class="literal">buf</code>是以<code class="literal">'\0'</code>结尾的。但即使用VLA仍然不够灵活，VLA是在栈上动态分配的，函数返回时就要释放，如果我们希望动态分配一块全局的内存空间，在各函数中都可以访问呢？由于全局数组无法定义成VLA，所以仍然不能满足要求。</p><p>其实在<a class="xref" href="ch20s05.html#link.vm">第 5 节 “虚拟内存管理”</a>提过，进程有一个堆空间，C标准库函数<code class="literal">malloc</code>可以在堆空间动态分配内存，它的底层通过<code class="literal">brk</code>系统调用向操作系统申请内存。动态分配的内存用完之后可以用<code class="literal">free</code>释放，更准确地说是归还给<code class="literal">malloc</code>，这样下次调用<code class="literal">malloc</code>时这块内存可以再次被分配。本节学习这两个函数的用法和工作原理。</p><pre class="programlisting">#include &lt;stdlib.h&gt;

void *malloc(size_t size);
返回值：成功返回所分配内存空间的首地址，出错返回NULL

void free(void *ptr);</pre><p><code class="literal">malloc</code>的参数<code class="literal">size</code>表示要分配的字节数，如果分配失败（可能是由于系统内存耗尽）则返回<code class="literal">NULL</code>。由于<code class="literal">malloc</code>函数不知道用户拿到这块内存要存放什么类型的数据，所以返回通用指针<code class="literal">void *</code>，用户程序可以转换成其它类型的指针再访问这块内存。<code class="literal">malloc</code>函数保证它返回的指针所指向的地址满足系统的对齐要求，例如在32位平台上返回的指针一定对齐到4字节边界，以保证用户程序把它转换成任何类型的指针都能用。</p><p>动态分配的内存用完之后可以用<code class="literal">free</code>释放掉，传给<code class="literal">free</code>的参数正是先前<code class="literal">malloc</code>返回的内存块首地址。举例如下：</p><div class="example"><a id="id2820249"></a><p class="title"><b>例 24.1. malloc和free</b></p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct {
	int number;
	char *msg;
} unit_t;

int main(void)
{
	unit_t *p = malloc(sizeof(unit_t));

	if (p == NULL) {
		printf("out of memory\n");
		exit(1);
	}
	p-&gt;number = 3;
	p-&gt;msg = malloc(20);
	strcpy(p-&gt;msg, "Hello world!");
	printf("number: %d\nmsg: %s\n", p-&gt;number, p-&gt;msg);
	free(p-&gt;msg);
	free(p);
	p = NULL;

	return 0;
}</pre></div></div><br class="example-break" /><p>关于这个程序要注意以下几点：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">unit_t *p = malloc(sizeof(unit_t));</code>这一句，等号右边是<code class="literal">void *</code>类型，等号左边是<code class="literal">unit_t *</code>类型，编译器会做隐式类型转换，我们讲过<code class="literal">void *</code>类型和任何指针类型之间可以相互隐式转换。</p></li><li><p>虽然内存耗尽是很不常见的错误，但写程序要规范，<code class="literal">malloc</code>之后应该判断是否成功。以后要学习的大部分系统函数都有成功的返回值和失败的返回值，每次调用系统函数都应该判断是否成功。</p></li><li><p><code class="literal">free(p);</code>之后，<code class="literal">p</code>所指的内存空间是归还了，但是<code class="literal">p</code>的值并没有变，因为从<code class="literal">free</code>的函数接口来看根本就没法改变<code class="literal">p</code>的值，<code class="literal">p</code>现在指向的内存空间已经不属于用户，换句话说，<code class="literal">p</code>成了野指针，为避免出现野指针，我们应该在<code class="literal">free(p);</code>之后手动置<code class="literal">p = NULL;</code>。</p></li><li><p>应该先<code class="literal">free(p-&gt;msg)</code>，再<code class="literal">free(p)</code>。如果先<code class="literal">free(p)</code>，<code class="literal">p</code>成了野指针，就不能再通过<code class="literal">p-&gt;msg</code>访问内存了。</p></li></ul></div><p>上面的例子只有一个简单的顺序控制流程，分配内存，赋值，打印，释放内存，退出程序。这种情况下即使不用<code class="literal">free</code>释放内存也可以，因为程序退出时整个进程地址空间都会释放，包括堆空间，该进程占用的所有内存都会归还给操作系统。但如果一个程序长年累月运行（例如网络服务器程序），并且在循环或递归中调用<code class="literal">malloc</code>分配内存，则必须有<code class="literal">free</code>与之配对，分配一次就要释放一次，否则每次循环都分配内存，分配完了又不释放，就会慢慢耗尽系统内存，这种错误称为内存泄漏（Memory Leak）<a id="id2820441" class="indexterm"></a>。另外，<code class="literal">malloc</code>返回的指针一定要保存好，只有把它传给<code class="literal">free</code>才能释放这块内存，如果这个指针丢失了，就没有办法<code class="literal">free</code>这块内存了，也会造成内存泄漏。例如：</p><pre class="programlisting">void foo(void)
{
	char *p = malloc(10);
	...
}</pre><p><code class="literal">foo</code>函数返回时要释放局部变量<code class="literal">p</code>的内存空间，它所指向的内存地址就丢失了，这10个字节也就没法释放了。内存泄漏的Bug很难找到，因为它不会像访问越界一样导致程序运行错误，少量内存泄漏并不影响程序的正确运行，大量的内存泄漏会使系统内存紧缺，导致频繁换页，不仅影响当前进程，而且把整个系统都拖得很慢。</p><p>关于<code class="literal">malloc</code>和<code class="literal">free</code>还有一些特殊情况。<code class="literal">malloc(0)</code>这种调用也是合法的，也会返回一个非<code class="literal">NULL</code>的指针，这个指针也可以传给<code class="literal">free</code>释放，但是不能通过这个指针访问内存。<code class="literal">free(NULL)</code>也是合法的，不做任何事情，但是<code class="literal">free</code>一个野指针是不合法的，例如先调用<code class="literal">malloc</code>返回一个指针<code class="literal">p</code>，然后连着调用两次<code class="literal">free(p);</code>，则后一次调用会产生运行时错误。</p><p><a class="xref" href="bi01.html#bibli.kr" title="The C Programming Language">[<abbr class="abbrev">K&amp;R</abbr>]</a>的8.7节给出了<code class="literal">malloc</code>和<code class="literal">free</code>的简单实现，基于环形链表。目前读者还没有学习链表，看那段代码会有点困难，我再做一些简化，图示如下，目的是让读者理解<code class="literal">malloc</code>和<code class="literal">free</code>的工作原理。<code class="literal">libc</code>的实现比这要复杂得多，但基本工作原理也是如此。读者只要理解了基本工作原理，就很容易分析在使用<code class="literal">malloc</code>和<code class="literal">free</code>时遇到的各种Bug了。</p><div class="figure"><a id="id2820626"></a><p class="title"><b>图 24.5. 简单的<code class="literal">malloc</code>和<code class="literal">free</code>实现</b></p><div class="figure-contents"><div><img src="images/interface.malloc.png" alt="简单的malloc和free实现" /></div></div></div><br class="figure-break" /><p>图中白色背景的框表示<code class="literal">malloc</code>管理的空闲内存块，深色背景的框不归<code class="literal">malloc</code>管，可能是已经分配给用户的内存块，也可能不属于当前进程，Break之上的地址不属于当前进程，需要通过<code class="literal">brk</code>系统调用向内核申请。每个内存块开头都有一个头节点，里面有一个指针字段和一个长度字段，指针字段把所有空闲块的头节点串在一起，组成一个环形链表，长度字段记录着头节点和后面的内存块加起来一共有多长，以8字节为单位（也就是以头节点的长度为单位）。</p><div class="orderedlist"><ol type="1"><li><p>一开始堆空间由一个空闲块组成，长度为7×8=56字节，除头节点之外的长度为48字节。</p></li><li><p>调用<code class="literal">malloc</code>分配8个字节，要在这个空闲块的末尾截出16个字节，其中新的头节点占了8个字节，另外8个字节返回给用户使用，注意返回的指针<code class="literal">p1</code>指向头节点后面的内存块。</p></li><li><p>又调用<code class="literal">malloc</code>分配16个字节，又在空闲块的末尾截出24个字节，步骤和上一步类似。</p></li><li><p>调用<code class="literal">free</code>释放<code class="literal">p1</code>所指向的内存块，内存块（包括头节点在内）归还给了<code class="literal">malloc</code>，现在<code class="literal">malloc</code>管理着两块不连续的内存，用环形链表串起来。注意这时<code class="literal">p1</code>成了野指针，指向不属于用户的内存，<code class="literal">p1</code>所指向的内存地址在Break之下，是属于当前进程的，所以访问<code class="literal">p1</code>时不会出现段错误，但在访问<code class="literal">p1</code>时这段内存可能已经被<code class="literal">malloc</code>再次分配出去了，可能会读到意外改写数据。另外注意，此时如果通过<code class="literal">p2</code>向右写越界，有可能覆盖右边的头节点，从而破坏<code class="literal">malloc</code>管理的环形链表，<code class="literal">malloc</code>就无法从一个空闲块的指针字段找到下一个空闲块了，找到哪去都不一定，全乱套了。</p></li><li><p>调用<code class="literal">malloc</code>分配16个字节，现在虽然有两个空闲块，各有8个字节可分配，但是这两块不连续，<code class="literal">malloc</code>只好通过<code class="literal">brk</code>系统调用抬高Break，获得新的内存空间。在<a class="xref" href="bi01.html#bibli.kr" title="The C Programming Language">[<abbr class="abbrev">K&amp;R</abbr>]</a>的实现中，每次调用<code class="literal">sbrk</code>函数时申请1024×8=8192个字节，在Linux系统上<code class="literal">sbrk</code>函数也是通过<code class="literal">brk</code>实现的，这里为了画图方便，我们假设每次调用<code class="literal">sbrk</code>申请32个字节，建立一个新的空闲块。</p></li><li><p>新申请的空闲块和前一个空闲块连续，因此可以合并成一个。在能合并时要尽量合并，以免空闲块越割越小，无法满足大的分配请求。</p></li><li><p>在合并后的这个空闲块末尾截出24个字节，新的头节点占8个字节，另外16个字节返回给用户。</p></li><li><p>调用<code class="literal">free(p3)</code>释放这个内存块，由于它和前一个空闲块连续，又重新合并成一个空闲块。注意，Break只能抬高而不能降低，从内核申请到的内存以后都归<code class="literal">malloc</code>管了，即使调用<code class="literal">free</code>也不会还给内核。</p></li></ol></div><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2820918"></a>习题</h4></div></div></div><p>1、小练习：编写一个小程序让它耗尽系统内存。观察一下，分配了多少内存后才会出现分配失败？内存耗尽之后会怎么样？会不会死机？</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch24.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch24.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch24s02.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 24 章 函数接口 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 2. 传入参数与传出参数</td></tr></table></div></body></html>
