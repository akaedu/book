<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. 哈希表</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch26.html" title="第 26 章 链表、二叉树和哈希表" /><link rel="prev" href="ch26s02.html" title="2. 二叉树" /><link rel="next" href="ch27.html" title="第 27 章 本阶段总结" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. 哈希表</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch26s02.html">上一页</a> </td><th width="60%" align="center">第 26 章 链表、二叉树和哈希表</th><td width="20%" align="right"> <a accesskey="n" href="ch27.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2846250"></a>3. 哈希表</h2></div></div></div><p>下图示意了哈希表（Hash Table）这种数据结构。</p><div class="figure"><a id="id2846258"></a><p class="title"><b>图 26.12. 哈希表</b></p><div class="figure-contents"><div><img src="images/linkedlist.hashtab.png" alt="哈希表" /></div></div></div><br class="figure-break" /><p>如上图所示，首先分配一个指针数组，数组的每个元素是一个链表的头指针，每个链表称为一个槽（Slot）<a id="id2846275" class="indexterm"></a>。哪个数据应该放入哪个槽中由哈希函数决定，在这个例子中我们简单地选取哈希函数h(x) = x % 11，这样任意数据x都可以映射成0~10之间的一个数，就是槽的编号，将数据放入某个槽的操作就是链表的插入操作。</p><p>如果每个槽里至多只有一个数据，可以想像这种情况下<code class="literal">search</code>、<code class="literal">insert</code>和<code class="literal">delete</code>操作的时间复杂度都是O(1)，但有时会有多个数据被哈希函数映射到同一个槽中，这称为碰撞（Collision）<a id="id2846311" class="indexterm"></a>，设计一个好的哈希函数可以把数据比较均匀地分布到各个槽中，尽量避免碰撞。如果能把n个数据比较均匀地分布到m个槽中，每个糟里约有n/m个数据，则<code class="literal">search</code>、<code class="literal">insert</code>和<code class="literal">delete</code>和操作的时间复杂度都是O(n/m)，如果n和m的比是常数，则时间复杂度仍然是O(1)。一般来说，要处理的数据越多，构造哈希表时分配的槽也应该越多，所以n和m成正比这个假设是成立的。</p><p>请读者自己编写程序构造这样一个哈希表，并实现<code class="literal">search</code>、<code class="literal">insert</code>和<code class="literal">delete</code>操作。</p><p>如果用我们学过的各种数据结构来表示n个数据的集合，下表是<code class="literal">search</code>、<code class="literal">insert</code>和<code class="literal">delete</code>操作在平均情况下的时间复杂度比较。</p><div class="table"><a id="id2846390"></a><p class="title"><b>表 26.1. 各种数据结构的search、insert和delete操作在平均情况下的时间复杂度比较</b></p><div class="table-contents"><table summary="各种数据结构的search、insert和delete操作在平均情况下的时间复杂度比较" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>数据结构</th><th>search</th><th>insert</th><th>delete</th></tr></thead><tbody><tr><td>数组</td><td>O(n)，有序数组折半查找是O(lgn)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>双向链表</td><td>O(n)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>排序二叉树</td><td>O(lgn)</td><td>O(lgn)</td><td>O(lgn)</td></tr><tr><td>哈希表（n与槽数m成正比）</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div></div><br class="table-break" /><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2846467"></a>习题</h3></div></div></div><p>1、统计一个文本文件中每个单词的出现次数，然后按出现次数排序并打印输出。单词由连续的英文字母组成，不区分大小写。</p><p>2、实现一个函数求两个数组的交集：<code class="literal">size_t intersect(const int a[], size_t nmema, const int b[], size_t nmemb, int c[], size_t nmemc);</code>。数组元素是32位<code class="literal">int</code>型的。数组<code class="literal">a</code>有<code class="literal">nmema</code>个元素且各不相同，数组<code class="literal">b</code>有<code class="literal">nmemb</code>个元素且各不相同。要求找出数组<code class="literal">a</code>和数组<code class="literal">b</code>的交集保存到数组<code class="literal">c</code>中，<code class="literal">nmemc</code>是数组<code class="literal">c</code>的最大长度，返回值表示交集中实际有多少个元素，如果交集中实际的元素数量超过了<code class="literal">nmemc</code>则返回<code class="literal">nmemc</code>个元素。数组<code class="literal">a</code>和数组<code class="literal">b</code>的元素数量可能会很大（比如上百万个），需要设计尽可能快的算法。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch26s02.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch26.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch27.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">2. 二叉树 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 27 章 本阶段总结</td></tr></table></div></body></html>
