<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. 变量的存储布局</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch19.html" title="第 19 章 汇编与C之间的关系" /><link rel="prev" href="ch19s02.html" title="2. main函数和启动例程" /><link rel="next" href="ch19s04.html" title="4. 结构体和联合体" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. 变量的存储布局</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch19s02.html">上一页</a> </td><th width="60%" align="center">第 19 章 汇编与C之间的关系</th><td width="20%" align="right"> <a accesskey="n" href="ch19s04.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2777491"></a>3. 变量的存储布局</h2></div></div></div><p>首先看下面的例子：</p><div class="example"><a id="id2777482"></a><p class="title"><b>例 19.2. 研究变量的存储布局</b></p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;

const int A = 10;
int a = 20;
static int b = 30;
int c;

int main(void)
{
	static int a = 40;
	char b[] = "Hello world";
	register int c = 50;

	printf("Hello world %d\n", c);

	return 0;
}</pre></div></div><br class="example-break" /><p>我们在全局作用域和<code class="literal">main</code>函数的局部作用域各定义了一些变量，并且引入一些新的关键字<code class="literal">const</code>、<code class="literal">static</code>、<code class="literal">register</code>来修饰变量，那么这些变量的存储空间是怎么分配的呢？我们编译之后用<code class="literal">readelf</code>命令看它的符号表，了解各变量的地址分布。注意在下面的清单中我把符号表按地址从低到高的顺序重新排列了，并且只截取我们关心的那几行。</p><pre class="screen">$ gcc main.c -g
$ readelf -a a.out
...
    68: 08048540     4 OBJECT  GLOBAL DEFAULT   15 A
    69: 0804a018     4 OBJECT  GLOBAL DEFAULT   23 a
    52: 0804a01c     4 OBJECT  LOCAL  DEFAULT   23 b
    53: 0804a020     4 OBJECT  LOCAL  DEFAULT   23 a.1589
    81: 0804a02c     4 OBJECT  GLOBAL DEFAULT   24 c
...</pre><p>变量A用<code class="literal">const</code>修饰，表示A是只读的，不可修改，它被分配的地址是0x8048540，从<code class="literal">readelf</code>的输出可以看到这个地址位于<code class="literal">.rodata</code>段：</p><pre class="screen">Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
...
  [13] .text             PROGBITS        08048360 000360 0001bc 00  AX  0   0 16
...
  [15] .rodata           PROGBITS        08048538 000538 00001c 00   A  0   0  4
...
  [23] .data             PROGBITS        0804a010 001010 000014 00  WA  0   0  4
  [24] .bss              NOBITS          0804a024 001024 00000c 00  WA  0   0  4
...</pre><p>它在文件中的地址是0x538~0x554，我们用<code class="literal">hexdump</code>命令看看这个段的内容：</p><pre class="screen">$ hexdump -C a.out
...
00000530  5c fe ff ff 59 5b c9 c3  03 00 00 00 01 00 02 00  |\...Y[..........|
00000540  0a 00 00 00 48 65 6c 6c  6f 20 77 6f 72 6c 64 20  |....Hello world |
00000550  25 64 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |%d..............|
...</pre><p>其中0x540地址处的<code class="literal">0a 00 00 00</code>就是变量A。我们还看到程序中的字符串字面值<code class="literal">"Hello world %d\n"</code>分配在<code class="literal">.rodata</code>段的末尾，在<a class="xref" href="ch08s04.html#array.string">第 4 节 “字符串”</a>说过字符串字面值是只读的，相当于在全局作用域定义了一个<code class="literal">const</code>数组：</p><pre class="programlisting">const char helloworld[] = {'H', 'e', 'l', 'l', 'o', ' ',
		 	'w', 'o', 'r', 'l', 'd', ' ', '%', 'd', '\n', '\0'};</pre><p>程序加载运行时，<code class="literal">.rodata</code>段和<code class="literal">.text</code>段通常合并到一个Segment中，操作系统将这个Segment的页面只读保护起来，防止意外的改写。这一点从<code class="literal">readelf</code>的输出也可以看出来：</p><pre class="screen"> Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame 
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag 
   06     
   07     .ctors .dtors .jcr .dynamic .got </pre><p>注意，像<code class="literal">A</code>这种<code class="literal">const</code>变量在定义时必须初始化。因为只有初始化时才有机会给它一个值，一旦定义之后就不能再改写了，也就是不能再赋值了。</p><p>从上面<code class="literal">readelf</code>的输出可以看到<code class="literal">.data</code>段从地址0x804a010开始，长度是0x14，也就是到地址0x804a024结束。在<code class="literal">.data</code>段中有三个变量，<code class="literal">a</code>，<code class="literal">b</code>和<code class="literal">a.1589</code>。</p><p><code class="literal">a</code>是一个<code class="literal">GLOBAL</code>的符号，而<code class="literal">b</code>被<code class="literal">static</code>关键字修饰了，导致它成为一个<code class="literal">LOCAL</code>的符号，所以<code class="literal">static</code>在这里的作用是声明<code class="literal">b</code>这个符号为<code class="literal">LOCAL</code>的，不被链接器处理，在下一章我们会看到，如果把多个目标文件链接在一起，<code class="literal">LOCAL</code>的符号只能在某一个目标文件中定义和使用，而不能定义在一个目标文件中却在另一个目标文件中使用。一个函数定义前面也可以用<code class="literal">static</code>修饰，表示这个函数名符号是<code class="literal">LOCAL</code>的。</p><p>还有一个<code class="literal">a.1589</code>是什么呢？它就是<code class="literal">main</code>函数中的<code class="literal">static int a</code>。函数中的<code class="literal">static</code>变量不同于以前我们讲的局部变量，它并不是在调用函数时分配，在函数返回时释放，而是像全局变量一样静态分配，所以用“<span class="quote">static</span>”（静态）这个词。另一方面，函数中的<code class="literal">static</code>变量的作用域和以前讲的局部变量一样，只在函数中起作用，比如<code class="literal">main</code>函数中的<code class="literal">a</code>这个变量名只在<code class="literal">main</code>函数中起作用，在别的函数中说变量<code class="literal">a</code>就不是指它了，所以编译器给它的符号名加了一个后缀，变成<code class="literal">a.1589</code>，以便和全局变量<code class="literal">a</code>以及其它函数的变量<code class="literal">a</code>区分开。</p><p><code class="literal">.bss</code>段从地址0x804a024开始（紧挨着<code class="literal">.data</code>段），长度为0xc，也就是到地址0x804a030结束。变量<code class="literal">c</code>位于这个段。从上面的<code class="literal">readelf</code>输出可以看到，<code class="literal">.data</code>和<code class="literal">.bss</code>在加载时合并到一个Segment中，这个Segment是可读可写的。<code class="literal">.bss</code>段和<code class="literal">.data</code>段的不同之处在于，<code class="literal">.bss</code>段在文件中不占存储空间，在加载时这个段用0填充。所以我们在<a class="xref" href="ch03s04.html#func.localvar">第 4 节 “全局变量、局部变量和作用域”</a>讲过，全局变量如果不初始化则初值为0，同理可以推断，<code class="literal">static</code>变量（不管是函数里的还是函数外的）如果不初始化则初值也是0，也分配在<code class="literal">.bss</code>段。</p><p>现在还剩下函数中的<code class="literal">b</code>和<code class="literal">c</code>这两个变量没有分析。上一节我们讲过函数的参数和局部变量是分配在栈上的，<code class="literal">b</code>是数组也一样，也是分配在栈上的，我们看<code class="literal">main</code>函数的反汇编代码：</p><pre class="screen">$ objdump -dS a.out
...
        char b[]="Hello world";
 8048430:       c7 45 ec 48 65 6c 6c    movl   $0x6c6c6548,-0x14(%ebp)
 8048437:       c7 45 f0 6f 20 77 6f    movl   $0x6f77206f,-0x10(%ebp)
 804843e:       c7 45 f4 72 6c 64 00    movl   $0x646c72,-0xc(%ebp)
        register int c = 50;
 8048445:       b8 32 00 00 00          mov    $0x32,%eax

        printf("Hello world %d\n", c);
 804844a:       89 44 24 04             mov    %eax,0x4(%esp)
 804844e:       c7 04 24 44 85 04 08    movl   $0x8048544,(%esp)
 8048455:       e8 e6 fe ff ff          call   8048340 &lt;printf@plt&gt;
...</pre><p>可见，给<code class="literal">b</code>初始化用的这个字符串<code class="literal">"Hello world"</code>并没有分配在<code class="literal">.rodata</code>段，而是直接写在指令里了，通过三条<code class="literal">movl</code>指令把12个字节写到栈上，这就是<code class="literal">b</code>的存储空间，如下图所示。</p><div class="figure"><a id="id2778223"></a><p class="title"><b>图 19.4. 数组的存储布局</b></p><div class="figure-contents"><div><img src="images/asmc.array.png" alt="数组的存储布局" /></div></div></div><br class="figure-break" /><p>注意，虽然栈是从高地址向低地址增长的，但数组总是从低地址向高地址排列的，按从低地址到高地址的顺序依次是<code class="literal">b[0]</code>、<code class="literal">b[1]</code>、<code class="literal">b[2]</code>……这样，</p><div class="literallayout"><p>数组元素<code class="literal">b[n]</code>的地址 = 数组的基地址（<code class="literal">b</code>做右值就表示这个基地址） + n × 每个元素的字节数</p></div><p>当n=0时，元素<code class="literal">b[0]</code>的地址就是数组的基地址，因此数组下标要从0开始而不是从1开始。</p><p>变量<code class="literal">c</code>并没有在栈上分配存储空间，而是直接存在<code class="literal">eax</code>寄存器里，后面调用<code class="literal">printf</code>也是直接从<code class="literal">eax</code>寄存器里取出<code class="literal">c</code>的值当参数压栈，这就是<code class="literal">register</code>关键字的作用，指示编译器尽可能分配一个寄存器来存储这个变量。我们还看到调用<code class="literal">printf</code>时对于<code class="literal">"Hello world %d\n"</code>这个参数压栈的是它在<code class="literal">.rodata</code>段中的首地址，而不是把整个字符串压栈，所以在<a class="xref" href="ch08s04.html#array.string">第 4 节 “字符串”</a>中说过，字符串在使用时可以看作数组名，如果做右值则表示数组首元素的地址（或者说指向数组首元素的指针），我们以后讲指针还要继续讨论这个问题。</p><p>以前我们用“<span class="quote">全局变量</span>”和“<span class="quote">局部变量</span>”这两个概念，主要是从作用域上区分的，现在看来用这两个概念给变量分类太笼统了，需要进一步细分。我们总结一下相关的C语法。</p><p>作用域（Scope）<a id="id2778383" class="indexterm"></a>这个概念适用于所有标识符，而不仅仅是变量，C语言的作用域分为以下几类：</p><div class="itemizedlist"><ul type="disc"><li><p>函数作用域（Function Scope）<a id="id2778399" class="indexterm"></a>，标识符在整个函数中都有效。只有语句标号属于函数作用域。标号在函数中不需要先声明后使用，在前面用一个<code class="literal">goto</code>语句也可以跳转到后面的某个标号，但仅限于同一个函数之中。</p></li><li><p>文件作用域（File Scope）<a id="id2778421" class="indexterm"></a>，标识符从它声明的位置开始直到这个程序文件<sup>[<a id="id2778429" href="#ftn.id2778429" class="footnote">30</a>]</sup>的末尾都有效。例如上例中<code class="literal">main</code>函数外面的<code class="literal">A</code>、<code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>，还有<code class="literal">main</code>也算，<code class="literal">printf</code>其实是在<code class="literal">stdio.h</code>中声明的，被包含到这个程序文件中了，所以也算文件作用域的。</p></li><li><p>块作用域（Block Scope）<a id="id2778553" class="indexterm"></a>，标识符位于一对{}括号中（函数体或语句块），从它声明的位置开始到右}括号之间有效。例如上例中<code class="literal">main</code>函数里的<code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>。此外，函数定义中的形参也算块作用域的，从声明的位置开始到函数末尾之间有效。</p></li><li><p>函数原型作用域（Function Prototype Scope）<a id="id2778593" class="indexterm"></a>，标识符出现在函数原型中，这个函数原型只是一个声明而不是定义（没有函数体），那么标识符从声明的位置开始到在这个原型末尾之间有效。例如<code class="literal">int foo(int a, int b);</code>中的<code class="literal">a</code>和<code class="literal">b</code>。</p></li></ul></div><p>对属于同一命名空间（Name Space）<a id="id2778626" class="indexterm"></a>的重名标识符，内层作用域的标识符将覆盖外层作用域的标识符，例如局部变量名在它的函数中将覆盖重名的全局变量。命名空间可分为以下几类：</p><div class="itemizedlist"><ul type="disc"><li><p>语句标号单独属于一个命名空间。例如在函数中局部变量和语句标号可以重名，互不影响。由于使用标号的语法和使用其它标识符的语法都不一样，编译器不会把它和别的标识符弄混。</p></li><li><p><code class="literal">struct</code>，<code class="literal">enum</code>和<code class="literal">union</code>（下一节介绍<code class="literal">union</code>）的类型Tag属于一个命名空间。由于Tag前面总是带<code class="literal">struct</code>，<code class="literal">enum</code>或<code class="literal">union</code>关键字，所以编译器不会把它和别的标识符弄混。</p></li><li><p><code class="literal">struct</code>和<code class="literal">union</code>的成员名属于一个命名空间。由于成员名总是通过<code class="literal">.</code>或<code class="literal">-&gt;</code>运算符来访问而不会单独使用，所以编译器不会把它和别的标识符弄混。</p></li><li><p>所有其它标识符，例如变量名、函数名、宏定义、<code class="literal">typedef</code>的类型名、<code class="literal">enum</code>成员等等都属于同一个命名空间。如果有重名的话，宏定义覆盖所有其它标识符，因为它在预处理阶段而不是编译阶段处理，除了宏定义之外其它几类标识符按上面所说的规则处理，内层作用域覆盖外层作用域。</p></li></ul></div><p>标识符的链接属性（Linkage）<a id="id2778755" class="indexterm"></a>有三种：</p><div class="itemizedlist"><ul type="disc"><li><p>外部链接（External Linkage）<a id="id2778771" class="indexterm"></a>，如果最终的可执行文件由多个程序文件链接而成，一个标识符在任意程序文件中即使声明多次也都代表同一个变量或函数，则这个标识符具有External Linkage。具有External Linkage的标识符编译后在符号表中是<code class="literal">GLOBAL</code>的符号。例如上例中<code class="literal">main</code>函数外面的<code class="literal">a</code>和<code class="literal">c</code>，<code class="literal">main</code>和<code class="literal">printf</code>也算。</p></li><li><p>内部链接（Internal Linkage）<a id="id2778824" class="indexterm"></a>，如果一个标识符在某个程序文件中即使声明多次也都代表同一个变量或函数，则这个标识符具有Internal Linkage。例如上例中<code class="literal">main</code>函数外面的<code class="literal">b</code>。如果有另一个<code class="literal">foo.c</code>程序和<code class="literal">main.c</code>链接在一起，在<code class="literal">foo.c</code>中也声明一个<code class="literal">static int b;</code>，则那个<code class="literal">b</code>和这个<code class="literal">b</code>不代表同一个变量。具有Internal Linkage的标识符编译后在符号表中是<code class="literal">LOCAL</code>的符号，但<code class="literal">main</code>函数里面那个<code class="literal">a</code>不能算Internal Linkage的，因为即使在同一个程序文件中，在不同的函数中声明多次，也不代表同一个变量。</p></li><li><p>无链接（No Linkage）<a id="id2778908" class="indexterm"></a>。除以上情况之外的标识符都属于No Linkage的，例如函数的局部变量，以及不表示变量和函数的其它标识符。</p></li></ul></div><p>存储类修饰符（Storage Class Specifier）<a id="id2778922" class="indexterm"></a>有以下几种关键字，可以修饰变量或函数声明：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">static</code>，用它修饰的变量的存储空间是静态分配的，用它修饰的文件作用域的变量或函数具有Internal Linkage。</p></li><li><p><code class="literal">auto</code>，用它修饰的变量在函数调用时自动在栈上分配存储空间，函数返回时自动释放，例如上例中<code class="literal">main</code>函数里的<code class="literal">b</code>其实就是用<code class="literal">auto</code>修饰的，只不过<code class="literal">auto</code>可以省略不写，<code class="literal">auto</code>不能修饰文件作用域的变量。</p></li><li><p><code class="literal">register</code>，编译器对于用<code class="literal">register</code>修饰的变量会尽可能分配一个专门的寄存器来存储，但如果实在分配不开寄存器，编译器就把它当<code class="literal">auto</code>变量处理了，<code class="literal">register</code>不能修饰文件作用域的变量。现在一般编译器的优化都做得很好了，它自己会想办法有效地利用CPU的寄存器，所以现在<code class="literal">register</code>关键字也用得比较少了。</p></li><li><p><code class="literal">extern</code>，上面讲过，链接属性是根据一个标识符多次声明时是不是代表同一个变量或函数来分类的，<code class="literal">extern</code>关键字就用于多次声明同一个标识符，下一章再详细介绍它的用法。</p></li><li><p><code class="literal">typedef</code>，在<a class="xref" href="ch16s02.html#op.sizeoftypedef">第 2.4 节 “sizeof运算符与typedef类型声明”</a>讲过这个关键字，它并不是用来修饰变量的，而是定义一个类型名。在那一节也讲过，看<code class="literal">typedef</code>声明怎么看呢，首先去掉<code class="literal">typedef</code>把它看成变量声明，看这个变量是什么类型的，那么<code class="literal">typedef</code>就定义了一个什么类型，也就是说，<code class="literal">typedef</code>在语法结构中出现的位置和前面几个关键字一样，也是修饰变量声明的，所以从语法（而不是语义）的角度把它和前面几个关键字归类到一起。</p></li></ul></div><p>注意，上面介绍的<code class="literal">const</code>关键字不是一个Storage Class Specifier，虽然看起来它也修饰一个变量声明，但是在以后介绍的更复杂的声明中<code class="literal">const</code>在语法结构中允许出现的位置和Storage Class Specifier是不完全相同的。<code class="literal">const</code>和以后要介绍的<code class="literal">restrict</code>和<code class="literal">volatile</code>关键字属于同一类语法元素，称为类型限定符（Type Qualifier）<a id="id2779137" class="indexterm"></a>。</p><p>变量的生存期（Storage Duration，或者Lifetime）<a id="id2779152" class="indexterm"></a>分为以下几类：</p><div class="itemizedlist"><ul type="disc"><li><p>静态生存期（Static Storage Duration）<a id="id2779166" class="indexterm"></a>，具有外部或内部链接属性，或者被<code class="literal">static</code>修饰的变量，在程序开始执行时分配和初始化一次，此后便一直存在直到程序结束。这种变量通常位于<code class="literal">.rodata</code>，<code class="literal">.data</code>或<code class="literal">.bss</code>段，例如上例中<code class="literal">main</code>函数外的<code class="literal">A</code>，<code class="literal">a</code>，<code class="literal">b</code>，<code class="literal">c</code>，以及<code class="literal">main</code>函数里的<code class="literal">a</code>。</p></li><li><p>自动生存期（Automatic Storage Duration）<a id="id2779247" class="indexterm"></a>，链接属性为无链接并且没有被<code class="literal">static</code>修饰的变量，这种变量在进入块作用域时在栈上或寄存器中分配，在退出块作用域时释放。例如上例中<code class="literal">main</code>函数里的<code class="literal">b</code>和<code class="literal">c</code>。</p></li><li><p>动态分配生存期（Allocated Storage Duration）<a id="id2779286" class="indexterm"></a>，以后会讲到调用<code class="literal">malloc</code>函数在进程的堆空间中分配内存，调用<code class="literal">free</code>函数可以释放这种存储空间。</p></li></ul></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id2778429" href="#id2778429" class="para">30</a>] </sup>为了容易阅读，这里我用了“<span class="quote">程序文件</span>”这个不严格的叫法。如果有文件<code class="literal">a.c</code>包含了<code class="literal">b.h</code>和<code class="literal">c.h</code>，那么我所说的“<span class="quote">程序文件</span>”指的是经过预处理把<code class="literal">b.h</code>和<code class="literal">c.h</code>在<code class="literal">a.c</code>中展开之后生成的代码，在C标准中称为编译单元（Translation Unit）<a id="id2778477" class="indexterm"></a>。每个编译单元可以分别编译成一个<code class="literal">.o</code>目标文件，最后这些目标文件用链接器链接到一起，成为一个可执行文件。C标准中大量使用一些非常不通俗的名词，除了编译单元之外，还有编译器叫Translator，变量叫Object，本书不会采用这些名词，因为我不是在写C标准。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch19s02.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch19.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch19s04.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">2. <code class="literal">main</code>函数和启动例程 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 4. 结构体和联合体</td></tr></table></div></body></html>
