<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 位运算</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch16.html" title="第 16 章 运算符详解" /><link rel="prev" href="ch16.html" title="第 16 章 运算符详解" /><link rel="next" href="ch16s02.html" title="2. 其它运算符" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 位运算</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch16.html">上一页</a> </td><th width="60%" align="center">第 16 章 运算符详解</th><td width="20%" align="right"> <a accesskey="n" href="ch16s02.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2761666"></a>1. 位运算</h2></div></div></div><p>整数在计算机中用二进制的位来表示，C语言提供一些运算符可以直接操作整数中的位，称为位运算，这些运算符的操作数都必须是整型的。在以后的学习中你会发现，有些信息利用整数中的某几个位来存储，要访问这些位，仅仅有对整数的操作是不够的，必须借助位运算，例如<a class="xref" href="apas02.html#app-encoding.utf8">第 2 节 “Unicode和UTF-8”</a>介绍的UTF-8编码就是如此，学完本节之后你应该能自己写出UTF-8的编码和解码程序。本节首先介绍各种位运算符，然后介绍与位运算有关的编程技巧。</p><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2761062"></a>1.1. 按位与、或、异或、取反运算</h3></div></div></div><p>在<a class="xref" href="ch04s03.html#cond.bool">第 3 节 “布尔代数”</a>讲过逻辑与、或、非运算，并列出了真值表，对于整数中的位也可以做与、或、非运算，C语言提供了按位与（Bitwise AND）<a id="id2761684" class="indexterm"></a>运算符&amp;、按位或（Bitwise OR）<a id="id2761693" class="indexterm"></a>运算符|和按位取反（Bitwise NOT）<a id="id2761700" class="indexterm"></a>运算符~，此外还有按位异或（Bitwise XOR）<a id="id2761708" class="indexterm"></a>运算符^，我们在<a class="xref" href="ch14s01.html#number.binary">第 1 节 “为什么计算机用二进制计数”</a>讲过异或运算。下面用二进制的形式举几个例子。</p><div class="figure"><a id="id2761724"></a><p class="title"><b>图 16.1. 位运算</b></p><div class="figure-contents"><div><img src="images/op.bitwise.png" alt="位运算" /></div></div></div><br class="figure-break" /><p>注意，&amp;、|、^运算符都是要做Usual Arithmetic Conversion的（其中有一步是Integer Promotion），~运算符也要做Integer Promotion，所以在C语言中其实并不存在8位整数的位运算，操作数在做位运算之前都至少被提升为<code class="literal">int</code>型了，上面用8位整数举例只是为了书写方便。比如：</p><pre class="programlisting">unsigned char c = 0xfc;
unsigned int i = ~c;</pre><p>计算过程是这样的：常量0xfc是<code class="literal">int</code>型的，赋给<code class="literal">c</code>要转成<code class="literal">unsigned char</code>，值不变；<code class="literal">c</code>的十六进制表示是fc，计算<code class="literal">~c</code>时先提升为整型（000000fc）然后取反，最后结果是ffffff03。注意，如果把<code class="literal">~c</code>看成是8位整数的取反，最后结果就得3了，这就错了。为了避免出错，一是尽量避免不同类型之间的赋值，二是每一步计算都要按上一章讲的类型转换规则仔细检查。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2761805"></a>1.2. 移位运算</h3></div></div></div><p>移位运算符（Bitwise Shift）<a id="id2761813" class="indexterm"></a>包括左移&lt;&lt;和右移&gt;&gt;。左移将一个整数的各二进制位全部左移若干位，例如0xcfffffff3&lt;&lt;2得到0x3fffffcc：</p><div class="figure"><a id="id2761824"></a><p class="title"><b>图 16.2. 左移运算</b></p><div class="figure-contents"><div><img src="images/op.shiftleft.png" alt="左移运算" /></div></div></div><br class="figure-break" /><p>最高两位的11被移出去了，最低两位又补了两个0，其它位依次左移两位。但要注意，移动的位数必须小于左操作数的总位数，比如上面的例子，左边是<code class="literal">unsigned int</code>型，如果左移的位数大于等于32位，则结果是Undefined。移位运算符不同于+ - * / ==等运算符，两边操作数的类型不要求一致，但两边操作数都要做Integer Promotion，整个表达式的类型和左操作数提升后的类型相同。</p><p>复习一下<a class="xref" href="ch14s02.html#number.convert">第 2 节 “不同进制之间的换算”</a>讲过的知识可以得出结论，<span class="emphasis"><em>在一定的取值范围内，将一个整数左移1位相当于乘以2</em></span>。比如二进制11（十进制3）左移一位变成110，就是6，再左移一位变成1100，就是12。读者可以自己验证这条规律对有符号数和无符号数都成立，对负数也成立。当然，如果左移改变了最高位（符号位），那么结果肯定不是乘以2了，所以我加了个前提“<span class="quote">在一定的取值范围内</span>”。由于计算机做移位比做乘法快得多，编译器可以利用这一点做优化，比如看到源代码中有<code class="literal">i * 8</code>，可以编译成移位指令而不是乘法指令。</p><p>当操作数是无符号数时，右移运算的规则和左移类似，例如0xcfffffff3&gt;&gt;2得到0x33fffffc：</p><div class="figure"><a id="id2761899"></a><p class="title"><b>图 16.3. 右移运算</b></p><div class="figure-contents"><div><img src="images/op.shiftright.png" alt="右移运算" /></div></div></div><br class="figure-break" /><p>最低两位的11被移出去了，最高两位又补了两个0，其它位依次右移两位。和左移类似，移动的位数也必须小于左操作数的总位数，否则结果是Undefined。在一定的取值范围内，将一个整数右移1位相当于除以2，小数部分截掉。</p><p>当操作数是有符号数时，右移运算的规则比较复杂：</p><div class="itemizedlist"><ul type="disc"><li><p>如果是正数，那么高位移入0</p></li><li><p>如果是负数，那么高位移入1还是0不一定，这是Implementation-defined的。对于x86平台的<code class="literal">gcc</code>编译器，最高位移入1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了“<span class="quote">右移1位相当于除以2</span>”的性质。</p></li></ul></div><p>综上所述，由于类型转换和移位等问题，用有符号数做位运算是很不方便的，所以，<span class="emphasis"><em>建议只对无符号数做位运算，以减少出错的可能</em></span>。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2761960"></a>习题</h4></div></div></div><p>1、下面两行<code class="literal">printf</code>打印的结果有何不同？请读者比较分析一下。<code class="literal">%x</code>转换说明的含义详见<a class="xref" href="ch25s02.html#stdlib.formatio">第 2.9 节 “格式化I/O函数”</a>。</p><pre class="programlisting">int i = 0xcffffff3;
printf("%x\n", 0xcffffff3&gt;&gt;2);
printf("%x\n", i&gt;&gt;2);</pre></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2761995"></a>1.3. 掩码</h3></div></div></div><p>如果要对一个整数中的某些位进行操作，怎样表示这些位在整数中的位置呢？可以用掩码（Mask）<a id="id2762004" class="indexterm"></a>来表示。比如掩码0x0000ff00表示对一个32位整数的8~15位进行操作，举例如下。</p><p>1、取出8~15位。</p><pre class="programlisting">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = (a &amp; mask) &gt;&gt; 8; /* 0x00000056 */</pre><p>这样也可以达到同样的效果：</p><pre class="programlisting">b = (a &gt;&gt; 8) &amp; ~(~0U &lt;&lt; 8);</pre><p>2、将8~15位清0。</p><pre class="programlisting">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = a &amp; ~mask; /* 0x12340078 */</pre><p>3、将8~15位置1。</p><pre class="programlisting">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = a | mask; /* 0x1234ff78 */</pre><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2762050"></a>习题</h4></div></div></div><p>1、统计一个无符号整数的二进制表示中1的个数，函数原型是<code class="literal">int countbit(unsigned int x);</code>。</p><p>2、用位操作实现无符号整数的乘法运算，函数原型是<code class="literal">unsigned int multiply(unsigned int x, unsigned int y);</code>。例如：(11011)<sub>2</sub>×(10010)<sub>2</sub>=((11011)<sub>2</sub>&lt;&lt;1)+((11011)<sub>2</sub>&lt;&lt;4)。</p><p>3、对一个32位无符号整数做循环右移，函数原型是<code class="literal">unsigned int rotate_right(unsigned int x);</code>。所谓循环右移就是把低位移出去的部分再补到高位上去，例如<code class="literal">rotate_right(0xdeadbeef, 16)</code>的值应该是0xefdeadbe。</p></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2762114"></a>1.4. 异或运算的一些特性</h3></div></div></div><p>1、一个数和自己做异或的结果是0。如果需要一个常数0，x86平台的编译器可能会生成这样的指令：<code class="literal">xorl %eax, %eax</code>。不管<code class="literal">eax</code>寄存器里的值原来是多少，做异或运算都能得到0，这条指令比同样效果的<code class="literal">movl $0, %eax</code>指令快，因为前者只需要在CPU内部计算，而后者需要访问内存，在下一章<a class="xref" href="ch17s05.html#arch.memh">第 5 节 “Memory Hierarchy”</a>详细介绍。</p><p>2、从异或的真值表可以看出，不管是0还是1，和0做异或保持原值不变，和1做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转，例如：</p><pre class="programlisting">unsigned int a, b, mask = 1U &lt;&lt; 6;
a = 0x12345678;
b = a ^ mask; /* flip the 6th bit */</pre><p>3、如果a<sub>1</sub> ^ a<sub>2</sub> ^ a<sub>3</sub> ^ ... ^ a<sub>n</sub>的结果是1，则表示a<sub>1</sub>、a<sub>2</sub>、a<sub>3</sub>...a<sub>n</sub>之中1的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验（Parity Check）<a id="id2762202" class="indexterm"></a>，比如在串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到的数据是否有误。</p><p>4、x ^ x ^ y == y，因为x ^ x == 0，0 ^ y == y。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用<code class="literal">temp = a; a = b; b = temp;</code>的办法了。利用位运算可以这样做交换：</p><pre class="programlisting">a = a ^ b;
b = b ^ a;
a = a ^ b;</pre><p>分析一下这个过程。为了避免混淆，把a和b的初值分别记为a<sub>0</sub>和b<sub>0</sub>。第一行，<code class="literal">a = a<sub>0</sub> ^ b<sub>0</sub></code>；第二行，把a的新值代入，得到<code class="literal">b = b<sub>0</sub> ^ a<sub>0</sub> ^ b<sub>0</sub></code>，等号右边的b<sub>0</sub>相当于上面公式中的x，a<sub>0</sub>相当于y，所以结果为a<sub>0</sub>；第三行，把a和b的新值代入，得到<code class="literal">a = a<sub>0</sub> ^ b<sub>0</sub> ^ a<sub>0</sub></code>，结果为b<sub>0</sub>。注意这个过程不能把同一个变量自己跟自己交换，而利用中间变量<code class="literal">temp</code>则可以交换。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2762311"></a>习题</h4></div></div></div><p>1、请在网上查找有关RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）<a id="id2762322" class="indexterm"></a>的资料，理解其实现原理，其实就是利用了本节的性质3和4。</p><p>2、交换两个变量的值，不得借助额外的存储空间，除了本节讲的方法之外你还能想出什么方法？本节讲的方法不能把同一个变量自己跟自己交换，你的方法有没有什么局限性？</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch16.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch16.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch16s02.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 16 章 运算符详解 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 2. 其它运算符</td></tr></table></div></body></html>
