<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. Side Effect与Sequence Point</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch16.html" title="第 16 章 运算符详解" /><link rel="prev" href="ch16s02.html" title="2. 其它运算符" /><link rel="next" href="ch16s04.html" title="4. 运算符总结" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. Side Effect与Sequence Point</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch16s02.html">上一页</a> </td><th width="60%" align="center">第 16 章 运算符详解</th><td width="20%" align="right"> <a accesskey="n" href="ch16s04.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2762987"></a>3. Side Effect与Sequence Point</h2></div></div></div><p>如果你只想规规矩矩地写代码，那么基本用不着看这一节。本节的内容基本上是钻牛角尖儿的，除了Short-circuit比较实用，其它写法都应该避免使用。但没办法，有时候不是你想钻牛角尖儿，而是有人逼你去钻牛角尖儿。这是我们的学员在找工作笔试时碰到的问题：</p><pre class="programlisting">int a=0;
a = (++a)+(++a)+(++a)+(++a);</pre><p>据我了解，似乎很多公司都有出这种笔试题的恶趣味。答案应该是Undefined，我甚至有些怀疑出题人是否真的知道答案。下面我来解释为什么是Undefined。</p><p>我们知道，调用一个函数可能产生Side Effect，使用某些运算符（++ -- = 复合赋值）也会产生Side Effect，如果一个表达式中隐含着多个Side Effect，究竟哪个先发生哪个后发生呢？C标准规定代码中的某些点是Sequence Point<a id="id2763025" class="indexterm"></a>，当执行到一个Sequence Point时，在此之前的Side Effect必须全部作用完毕，在此之后的Side Effect必须一个都没发生。至于两个Sequence Point之间的多个Side Effect哪个先发生哪个后发生则没有规定，编译器可以任意选择各Side Effect的作用顺序。下面详细解释各种Sequence Point。</p><p>1、调用一个函数时，在所有准备工作做完之后、函数调用开始之前是Sequence Point。比如调用<code class="literal">foo(f(), g())</code>时，<code class="literal">foo</code>、<code class="literal">f()</code>、<code class="literal">g()</code>这三个表达式哪个先求值哪个后求值是Unspecified，但是必须都求值完了才能做最后的函数调用，所以<code class="literal">f()</code>和<code class="literal">g()</code>的Side Effect按什么顺序发生不一定，但必定在这些Side Effect全部作用完之后才开始调用<code class="literal">foo</code>函数。</p><p>2、条件运算符?:、逗号运算符、逻辑与&amp;&amp;、逻辑或||的第一个操作数求值之后是Sequence Point。我们刚讲过条件运算符和逗号运算符，条件运算符要根据表达式1的值是否为真决定下一步求表达式2还是表达式3的值，如果决定求表达式2的值，表达式3就不会被求值了，反之也一样，逗号运算符也是这样，表达式1求值结束才继续求表达式2的值。</p><p>逻辑与和逻辑或早在<a class="xref" href="ch04s03.html#cond.bool">第 3 节 “布尔代数”</a>就讲了，但在初学阶段我一直回避它们的操作数求值顺序问题。这两个运算符和条件运算符类似，先求左操作数的值，然后根据这个值是否为真，右操作数可能被求值，也可能不被求值。比如<a class="xref" href="ch08s05.html#array.scissor">例 8.5 “剪刀石头布”</a>这个程序中的这几句：</p><pre class="programlisting">ret = scanf("%d", &amp;man);
if (ret != 1 || man &lt; 0 || man &gt; 2) {
	printf("Invalid input! Please input 0, 1 or 2.\n");
	continue;
}</pre><p>其实可以写得更简单（类似于<a class="xref" href="bi01.html#bibli.kr" title="The C Programming Language">[<abbr class="abbrev">K&amp;R</abbr>]</a>的简洁风格）：</p><pre class="programlisting">if (scanf("%d", &amp;man) != 1 || man &lt; 0 || man &gt; 2) {
	printf("Invalid input! Please input 0, 1 or 2.\n");
	continue;
}</pre><p>这个控制表达式的求值顺序是：先求<code class="literal">scanf("%d", &amp;man) = 1</code>的值，如果<code class="literal">scanf</code>调用失败，则返回值不等于1成立，||运算有一个操作数为真则整个表达式为真，这时直接执行下一句<code class="literal">printf</code>，根本不会再去求<code class="literal">man &lt; 0</code>或<code class="literal">man &gt; 2</code>的值；如果<code class="literal">scanf</code>调用成功，则读入的数保存在变量<code class="literal">man</code>中，并且返回值等于1，那么说它不等于1就不成立了，第一个||运算的左操作数为假，就会去求右操作数<code class="literal">man &lt; 0</code>的值作为整个表达式的值，这时变量<code class="literal">man</code>的值正是<code class="literal">scanf</code>读上来的值，我们判断它是否在[0, 2]之间，如果<code class="literal">man &lt; 0</code>不成立，则整个表达式<code class="literal">scanf("%d", &amp;man) != 1 || man &lt; 0 </code>的值为假，也就是第二个||运算的左操作数为假，所以最后求右操作数<code class="literal">man &gt; 2</code>的值作为整个表达式的值。</p><p>&amp;&amp;运算与此类似，<code class="literal">a &amp;&amp; b</code>的计算过程是：首先求表达式<code class="literal">a</code>的值，如果<code class="literal">a</code>的值是假则整个表达式的值是假，不会再去求<code class="literal">b</code>的值；如果<code class="literal">a</code>的值是真，则下一步求<code class="literal">b</code>的值作为整个表达式的值。所以，<code class="literal">a &amp;&amp; b</code>相当于“<span class="quote">if a then b</span>”，而<code class="literal">a || b</code>相当于“<span class="quote">if not a then b</span>”。这种特性称为Short-circuit<a id="id2763307" class="indexterm"></a>，很多人喜欢利用Short-circuit特性简化代码。</p><p>3、在一个完整的声明末尾是Sequence Point，所谓完整的声明是指这个声明不是另外一个声明的一部分。比如声明<code class="literal">int a[10], b[20];</code>，在<code class="literal">a[10]</code>末尾是Sequence Point，在<code class="literal">b[20]</code>末尾也是。</p><p>4、在一个完整的表达式末尾是Sequence Point，所谓完整的表达式是指这个表达式不是另外一个表达式的一部分。所以如果有<code class="literal">f(); g();</code>这样两条语句，<code class="literal">f()</code>和<code class="literal">g()</code>是两个完整的表达式，<code class="literal">f()</code>的Side Effect必定在<code class="literal">g()</code>之前发生。</p><p>5、在库函数即将返回时是Sequence Point。这条规则似乎可以包含在上一条规则里面，因为函数返回时必然会结束掉一个完整的表达式。而事实上很多库函数是以宏定义的形式实现的（<a class="xref" href="ch21s02.html#prep.funcmacro">第 2.1 节 “函数式宏定义”</a>），并不是真正的函数，所以才需要有这条规则。</p><p>还有两种Sequence Point和某些C标准库函数的执行过程相关，此处从略，有兴趣的读者可参考<a class="xref" href="bi01.html#bibli.c99" title="ISO/IEC 9899: Programming Languages － C">[<abbr class="abbrev">C99</abbr>]</a>的Annex C。</p><p>现在可以分析一下本节开头的例子了。<code class="literal">a = (++a)+(++a)+(++a)+(++a);</code>的结果之所以是Undefined，因为在这个表达式中有五个Side Effect都在改变<code class="literal">a</code>的值，这些Side Effect按什么顺序发生不一定，只知道在整个表达式求值结束时一定都发生了。比如现在求第二个<code class="literal">++a</code>的值，这时第一个、第三个、第四个<code class="literal">++a</code>的Side Effect发生了没有，<code class="literal">a</code>的值被加过几次了，这些都不确定，所以第二个<code class="literal">++a</code>的值也不确定。这行代码用不同平台的不同编译器来编译结果是不同的，甚至在同一平台上用同一编译器的不同版本来编译也可能不同。</p><p>写表达式应遵循的原则一：<span class="emphasis"><em>在两个Sequence Point之间，同一个变量的值只允许被改变一次</em></span>。仅有这一条原则还不够，例如<code class="literal">a[i++] = i;</code>的变量<code class="literal">i</code>只改变了一次，但结果仍是Undefined，因为等号左边改<code class="literal">i</code>的值，等号右边读<code class="literal">i</code>的值，到底是先改还是先读？这个读写顺序是不确定的。但为什么<code class="literal">i = i + 1;</code>就没有歧义呢？虽然也是等号左边改<code class="literal">i</code>的值，等号右边读<code class="literal">i</code>的值，但你不读出<code class="literal">i</code>的值就没法计算<code class="literal">i + 1</code>，那拿什么去改<code class="literal">i</code>的值呢？所以这个读写顺序是确定的。写表达式应遵循的原则二：<span class="emphasis"><em>如果在两个Sequence Point之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写</em></span>。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch16s02.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch16.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch16s04.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">2. 其它运算符 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 4. 运算符总结</td></tr></table></div></body></html>
