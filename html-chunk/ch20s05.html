<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5. 虚拟内存管理</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch20.html" title="第 20 章 链接详解" /><link rel="prev" href="ch20s04.html" title="4. 共享库" /><link rel="next" href="ch21.html" title="第 21 章 预处理" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. 虚拟内存管理</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch20s04.html">上一页</a> </td><th width="60%" align="center">第 20 章 链接详解</th><td width="20%" align="right"> <a accesskey="n" href="ch21.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2791323"></a>5. 虚拟内存管理</h2></div></div></div><p>我们知道操作系统利用体系结构提供的VA到PA的转换机制实现虚拟内存管理。有了共享库的基础知识之后，现在我们可以进一步理解虚拟内存管理了。首先分析一个例子：</p><pre class="screen">$ ps
  PID TTY          TIME CMD
29977 pts/0    00:00:00 bash
30032 pts/0    00:00:00 ps
$ cat /proc/29977/maps 
08048000-080f4000 r-xp 00000000 08:15 688142     /bin/bash
080f4000-080f9000 rw-p 000ac000 08:15 688142     /bin/bash
080f9000-080fe000 rw-p 080f9000 00:00 0 
09283000-09497000 rw-p 09283000 00:00 0          [heap]
b7ca8000-b7cb2000 r-xp 00000000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
b7cb2000-b7cb3000 r--p 00009000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
b7cb3000-b7cb4000 rw-p 0000a000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
...
b7e15000-b7f6d000 r-xp 00000000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
b7f6d000-b7f6f000 r--p 00158000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
b7f6f000-b7f70000 rw-p 0015a000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
...
b7fbd000-b7fd7000 r-xp 00000000 08:15 565466     /lib/ld-2.8.90.so
b7fd7000-b7fd8000 r-xp b7fd7000 00:00 0          [vdso]
b7fd8000-b7fd9000 r--p 0001a000 08:15 565466     /lib/ld-2.8.90.so
b7fd9000-b7fda000 rw-p 0001b000 08:15 565466     /lib/ld-2.8.90.so
bfac5000-bfada000 rw-p bffeb000 00:00 0          [stack]</pre><p>用<code class="literal">ps</code>命令查看当前终端下的进程，得知<code class="literal">bash</code>进程的id是29977，然后用<code class="literal">cat /proc/29977/maps</code>命令查看它的虚拟地址空间。<code class="literal">/proc</code>目录中的文件并不是真正的磁盘文件，而是由内核虚拟出来的文件系统，当前系统中运行的每个进程在<code class="literal">/proc</code>下都有一个子目录，目录名就是进程的id，查看目录下的文件可以得到该进程的相关信息。此外，用<code class="literal">pmap 29977</code>命令也可以得到类似的输出结果。</p><div class="figure"><a id="id2791407"></a><p class="title"><b>图 20.4. 进程地址空间</b></p><div class="figure-contents"><div><img src="images/link.addrspace.png" alt="进程地址空间" /></div></div></div><br class="figure-break" /><p>在<a class="xref" href="ch17s04.html#arch.mmu">第 4 节 “MMU”</a>讲过，x86平台的虚拟地址空间是0x0000 0000~0xffff ffff，大致上前3GB（0x0000 0000~0xbfff ffff）是用户空间，后1GB（0xc000 0000~0xffff ffff）是内核空间，在这里得到了印证。0x0804 8000-0x080f 4000是从<code class="literal">/bin/bash</code>加载到内存的，访问权限为<code class="literal">r-x</code>，表示Text Segment，包含<code class="literal">.text</code>段、<code class="literal">.rodata</code>段、<code class="literal">.plt</code>段等。0x080f 4000-0x080f 9000也是从<code class="literal">/bin/bash</code>加载到内存的，访问权限为<code class="literal">rw-</code>，表示Data Segment，包含<code class="literal">.data</code>段、<code class="literal">.bss</code>段等。</p><p>0x0928 3000-0x0949 7000不是从磁盘文件加载到内存的，这段空间称为堆（Heap）<a id="id2791494" class="indexterm"></a>，以后会讲到用<code class="literal">malloc</code>函数动态分配内存是在这里分配的。从0xb7ca 8000开始是共享库的映射空间，每个共享库也分为几个Segment，每个Segment有不同的访问权限。可以看到，从堆空间的结束地址（0x0949 7000）到共享库映射空间的起始地址（0xb7ca 8000）之间有很大的地址空洞，在动态分配内存时堆空间是可以向高地址增长的。堆空间的地址上限（0x09497000）称为Break<a id="id2791525" class="indexterm"></a>，堆空间要向高地址增长就要抬高Break，映射新的虚拟内存页面到物理内存，这是通过系统调用<code class="literal">brk</code>实现的，<code class="literal">malloc</code>函数也是调用<code class="literal">brk</code>向内核请求分配内存的。</p><p><code class="literal">/lib/ld-2.8.90.so</code>就是动态链接器<code class="literal">/lib/ld-linux.so.2</code>，后者是前者的符号链接。标有<code class="literal">[vdso]</code>的地址范围是<code class="literal">linux-gate.so.1</code>的映射空间，我们讲过这个共享库是由内核虚拟出来的。0xbfac 5000-0xbfad a000是栈空间，其中高地址的部分保存着进程的环境变量和命令行参数，低地址的部分保存函数栈帧，栈空间是向低地址增长的，但显然没有堆空间那么大的可供增长的余地，因为实际的应用程序动态分配大量内存的并不少见，但是有几十层深的函数调用并且每层调用都有很多局部变量的非常少见。总之，栈空间是可能用尽的，并且比堆空间更容易用尽，在<a class="xref" href="ch05s03.html#func2.recursion">第 3 节 “递归”</a>讲过，无穷递归会用尽栈空间最终导致段错误。</p><p>虚拟内存管理起到了什么作用呢？可以从以下几个方面来理解。</p><p>第一，虚拟内存管理可以控制物理内存的访问权限。物理内存本身是不限制访问的，任何地址都可以读写，而操作系统要求不同的页面具有不同的访问权限，这是利用CPU模式和MMU的内存保护机制实现的。例如，Text Segment被只读保护起来，防止被错误的指令意外改写，内核地址空间也被保护起来，防止在用户模式下执行错误的指令意外改写内核数据。这样，执行错误指令或恶意代码的破坏能力受到了限制，顶多使当前进程因段错误终止，而不会影响整个系统的稳定性。</p><p>第二，虚拟内存管理最主要的作用是让每个进程有独立的地址空间。所谓独立的地址空间是指，不同进程中的同一个VA被MMU映射到不同的PA，并且在某一个进程中访问任何地址都不可能访问到另外一个进程的数据，这样使得任何一个进程由于执行错误指令或恶意代码导致的非法内存访问都不会意外改写其它进程的数据，不会影响其它进程的运行，从而保证整个系统的稳定性。另一方面，每个进程都认为自己独占整个虚拟地址空间，这样链接器和加载器的实现会比较容易，不必考虑各进程的地址范围是否冲突。</p><p>继续前面的实验，再打开一个终端窗口，看一下这个新的<code class="literal">bash</code>进程的地址空间，可以发现和先前的<code class="literal">bash</code>进程地址空间的布局差不多：</p><pre class="screen">$ ps
  PID TTY          TIME CMD
30697 pts/1    00:00:00 bash
30749 pts/1    00:00:00 ps
$ cat /proc/30697/maps
08048000-080f4000 r-xp 00000000 08:15 688142     /bin/bash
080f4000-080f9000 rw-p 000ac000 08:15 688142     /bin/bash
080f9000-080fe000 rw-p 080f9000 00:00 0 
082d7000-084f9000 rw-p 082d7000 00:00 0          [heap]
b7cf1000-b7cfb000 r-xp 00000000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
b7cfb000-b7cfc000 r--p 00009000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
b7cfc000-b7cfd000 rw-p 0000a000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
...
b7e5e000-b7fb6000 r-xp 00000000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
b7fb6000-b7fb8000 r--p 00158000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
b7fb8000-b7fb9000 rw-p 0015a000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
...
b8006000-b8020000 r-xp 00000000 08:15 565466     /lib/ld-2.8.90.so
b8020000-b8021000 r-xp b8020000 00:00 0          [vdso]
b8021000-b8022000 r--p 0001a000 08:15 565466     /lib/ld-2.8.90.so
b8022000-b8023000 rw-p 0001b000 08:15 565466     /lib/ld-2.8.90.so
bff0e000-bff23000 rw-p bffeb000 00:00 0          [stack]</pre><p>该进程也占用了0x0000 0000-0xbfff ffff的地址空间，Text Segment也是0x0804 8000-0x080f 4000，Data Segment也是0x080f 4000-0x080f 9000，和先前的进程一模一样，因为这些地址是在编译链接时写进<code class="literal">/bin/bash</code>这个可执行文件的，两个进程都加载它。这两个进程在同一个系统中同时运行着，它们的Data Segment占用相同的VA，但是两个进程各自干各自的事情，显然Data Segment中的数据应该是不同的，相同的VA怎么会有不同的数据呢？因为它们被映射到不同的PA。如下图所示。</p><div class="figure"><a id="id2791724"></a><p class="title"><b>图 20.5. 进程地址空间是独立的</b></p><div class="figure-contents"><div><img src="images/link.sepva.png" alt="进程地址空间是独立的" /></div></div></div><br class="figure-break" /><p>从图中还可以看到，两个进程都是<code class="literal">bash</code>进程，Text Segment是一样的，并且Text Segment是只读的，不会被改写，因此操作系统会安排两个进程的Text Segment共享相同的物理页面。由于每个进程都有自己的一套VA到PA的映射表，整个地址空间中的任何VA都在每个进程自己的映射表中查找相应的PA，因此不可能访问到其它进程的地址，也就没有可能意外改写其它进程的数据。</p><p>另外，注意到两个进程的共享库加载地址并不相同，共享库的加载地址是在运行时决定的，而不是写在<code class="literal">/bin/bash</code>这个可执行文件中。但即使如此，也不影响两个进程共享相同物理页面中的共享库，当然，只有只读的部分是共享的，可读可写的部分不共享。</p><p>使用共享库可以大大节省内存。比如<code class="literal">libc</code>，系统中几乎所有的进程都映射<code class="literal">libc</code>到自己的进程地址空间，而<code class="literal">libc</code>的只读部分在物理内存中只需要存在一份，就可以被所有进程共享，这就是“<span class="quote">共享库</span>”这个名称的由来了。</p><p>现在我们也可以理解为什么共享库必须是位置无关代码了。比如<code class="literal">libc</code>，不同的进程虽然共享<code class="literal">libc</code>所在的物理页面，但这些物理页面被映射到各进程的虚拟地址空间时却位于不同的地址，所以要求<code class="literal">libc</code>的代码不管加载到什么地址都能正确执行。</p><p>第三，VA到PA的映射会给分配和释放内存带来方便，物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存。比如要用<code class="literal">malloc</code>分配一块很大的内存空间，虽然有足够多的空闲物理内存，却没有足够大的<span class="emphasis"><em>连续</em></span>空闲内存，这时就可以分配多个不连续的物理页面而映射到连续的虚拟地址范围。如下图所示。</p><div class="figure"><a id="id2791851"></a><p class="title"><b>图 20.6. 不连续的PA可以映射为连续的VA</b></p><div class="figure-contents"><div><img src="images/link.discontpa.png" alt="不连续的PA可以映射为连续的VA" /></div></div></div><br class="figure-break" /><p>第四，一个系统如果同时运行着很多进程，为各进程分配的内存之和可能会大于实际可用的物理内存，虚拟内存管理使得这种情况下各进程仍然能够正常运行。因为各进程分配的只不过是虚拟内存的页面，这些页面的数据可以映射到物理页面，也可以临时保存到磁盘上而不占用物理页面，在磁盘上临时保存虚拟内存页面的可能是一个磁盘分区，也可能是一个磁盘文件，称为交换设备（Swap Device）<a id="id2791885" class="indexterm"></a>。当物理内存不够用时，将一些不常用的物理页面中的数据临时保存到交换设备，然后这个物理页面就认为是空闲的了，可以重新分配给进程使用，这个过程称为换出（Page out）<a id="id2791897" class="indexterm"></a>。如果进程要用到被换出的页面，就从交换设备再加载回物理内存，这称为换入（Page in）<a id="id2791906" class="indexterm"></a>。换出和换入操作统称为换页（Paging）<a id="id2791913" class="indexterm"></a>，因此：</p><div class="literallayout"><p>系统中可分配的内存总量 = 物理内存的大小 + 交换设备的大小</p></div><p>如下图所示。第一张图是换出，将物理页面中的数据保存到磁盘，并解除地址映射，释放物理页面。第二张图是换入，从空闲的物理页面中分配一个，将磁盘暂存的页面加载回内存，并建立地址映射。</p><div class="figure"><a id="id2791937"></a><p class="title"><b>图 20.7. 换页</b></p><div class="figure-contents"><div><img src="images/link.swap.png" alt="换页" /></div></div></div><br class="figure-break" /></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch20s04.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch20.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch21.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">4. 共享库 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 21 章 预处理</td></tr></table></div></body></html>
