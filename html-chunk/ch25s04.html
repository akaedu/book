<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4. 分配内存的函数</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch25.html" title="第 25 章 C标准库" /><link rel="prev" href="ch25s03.html" title="3. 数值字符串转换函数" /><link rel="next" href="ch26.html" title="第 26 章 链表、二叉树和哈希表" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. 分配内存的函数</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch25s03.html">上一页</a> </td><th width="60%" align="center">第 25 章 C标准库</th><td width="20%" align="right"> <a accesskey="n" href="ch26.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2835580"></a>4. 分配内存的函数</h2></div></div></div><p>除了<code class="literal">malloc</code>之外，C标准库还提供了另外两个在堆空间分配内存的函数，它们分配的内存同样由<code class="literal">free</code>释放。</p><pre class="programlisting">#include &lt;stdlib.h&gt;

void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);
返回值：成功返回所分配内存空间的首地址，出错返回NULL</pre><p><code class="literal">calloc</code>的参数很像<code class="literal">fread</code>/<code class="literal">fwrite</code>的参数，分配<code class="literal">nmemb</code>个元素的内存空间，每个元素占<code class="literal">size</code>字节，并且<code class="literal">calloc</code>负责把这块内存空间用字节0填充，而<code class="literal">malloc</code>并不负责把分配的内存空间清零。</p><p>有时候用<code class="literal">malloc</code>或<code class="literal">calloc</code>分配的内存空间使用了一段时间之后需要改变它的大小，一种办法是调用<code class="literal">malloc</code>分配一块新的内存空间，把原内存空间中的数据拷到新的内存空间，然后调用<code class="literal">free</code>释放原内存空间。使用<code class="literal">realloc</code>函数简化了这些步骤，把原内存空间的指针<code class="literal">ptr</code>传给<code class="literal">realloc</code>，通过参数<code class="literal">size</code>指定新的大小（字节数），<code class="literal">realloc</code>返回新内存空间的首地址，并释放原内存空间。新内存空间中的数据尽量和原来保持一致，如果<code class="literal">size</code>比原来小，则前<code class="literal">size</code>个字节不变，后面的数据被截断，如果<code class="literal">size</code>比原来大，则原来的数据全部保留，后面长出来的一块内存空间未初始化（<code class="literal">realloc</code>不负责清零）。注意，参数<code class="literal">ptr</code>要么是<code class="literal">NULL</code>，要么必须是先前调用<code class="literal">malloc</code>、<code class="literal">calloc</code>或<code class="literal">realloc</code>返回的指针，不能把任意指针传给<code class="literal">realloc</code>要求重新分配内存空间。作为两个特例，如果调用<code class="literal">realloc(NULL, size)</code>，则相当于调用<code class="literal">malloc(size)</code>，如果调用<code class="literal">realloc(ptr, 0)</code>，<code class="literal">ptr</code>不是<code class="literal">NULL</code>，则相当于调用<code class="literal">free(ptr)</code>。</p><pre class="programlisting">#include &lt;alloca.h&gt;

void *alloca(size_t size);
返回值：返回所分配内存空间的首地址，如果size太大导致栈空间耗尽，结果是未定义的</pre><p>参数<code class="literal">size</code>是请求分配的字节数，<code class="literal">alloca</code>函数不是在堆上分配空间，而是在调用者函数的栈帧上分配空间，类似于C99的变长数组，当调用者函数返回时自动释放栈帧，所以不需要<code class="literal">free</code>。这个函数不属于C标准库，而是在POSIX标准中定义的。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch25s03.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch25.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch26.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">3. 数值字符串转换函数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 26 章 链表、二叉树和哈希表</td></tr></table></div></body></html>
