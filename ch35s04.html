<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4. 编程练习</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch35.html" title="第 35 章 线程" /><link rel="prev" href="ch35s03.html" title="3. 线程间同步" /><link rel="next" href="ch36.html" title="第 36 章 TCP/IP协议基础" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. 编程练习</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch35s03.html">上一页</a> </td><th width="60%" align="center">第 35 章 线程</th><td width="20%" align="right"> <a accesskey="n" href="ch36.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2897498"></a>4. 编程练习</h2></div></div></div><p>哲学家就餐问题。这是由计算机科学家Dijkstra提出的经典死锁场景。</p><p>原版的故事里有五个哲学家(不过我们写的程序可以有N个哲学家)，这些哲学家们只做两件事－－思考和吃饭，他们思考的时候不需要任何共享资源，但是吃饭的时候就必须使用餐具，而餐桌上的餐具是有限的，原版的故事里，餐具是叉子，吃饭的时候要用两把叉子把面条从碗里捞出来。很显然把叉子换成筷子会更合理，所以：一个哲学家需要两根筷子才能吃饭。</p><p>现在引入问题的关键：这些哲学家很穷，只买得起五根筷子。他们坐成一圈，两个人的中间放一根筷子。哲学家吃饭的时候必须同时得到左手边和右手边的筷子。如果他身边的任何一位正在使用筷子，那他只有等着。</p><p>假设哲学家的编号是A、B、C、D、E，筷子编号是1、2、3、4、5，哲学家和筷子围成一圈如下图所示：</p><div class="figure"><a id="id2897541"></a><p class="title"><b>图 35.2. 哲学家问题</b></p><div class="figure-contents"><div><img src="images/thread.philosopher.png" alt="哲学家问题" /></div></div></div><br class="figure-break" /><p>每个哲学家都是一个单独的线程，每个线程循环做以下动作：思考rand()%10秒，然后先拿左手边的筷子再拿右手边的筷子（筷子这种资源可以用mutex表示），有任何一边拿不到就一直等着，全拿到就吃饭rand()%10秒，然后放下筷子。</p><p>编写程序仿真哲学家就餐的场景：</p><pre class="screen">Philosopher A fetches chopstick 5
Philosopher B fetches chopstick 1
Philosopher B fetches chopstick 2
Philosopher D fetches chopstick 3
Philosopher B releases chopsticks 1 2
Philosopher A fetches chopstick 1
Philosopher C fetches chopstick 2
Philosopher A releases chopsticks 5 1
...</pre><p>分析一下，这个过程有没有可能产生死锁？调用usleep(3)函数可以实现微秒级的延时，试着用usleep(3)加快仿真的速度，看能不能观察到死锁现象。然后修改上述算法避免产生死锁。
</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch35s03.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch35.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch36.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">3. 线程间同步 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 36 章 TCP/IP协议基础</td></tr></table></div></body></html>
