<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 指针的基本概念</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C编程一站式学习" /><link rel="up" href="ch23.html" title="第 23 章 指针" /><link rel="prev" href="ch23.html" title="第 23 章 指针" /><link rel="next" href="ch23s02.html" title="2. 指针类型的参数和返回值" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 指针的基本概念</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch23.html">上一页</a> </td><th width="60%" align="center">第 23 章 指针</th><td width="20%" align="right"> <a accesskey="n" href="ch23s02.html">下一页</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2809880"></a>1. 指针的基本概念</h2></div></div></div><p>在<a class="xref" href="ch12.html#stackqueue">第 12 章 <i>栈与队列</i></a>讲过，堆栈有栈顶指针，队列有头指针和尾指针，这些概念中的“<span class="quote">指针</span>”本质上是一个整数，是数组的索引，通过指针访问数组中的某个元素。在<a class="xref" href="ch20s04.html#link.indirect">图 20.3 “间接寻址”</a>我们又看到另外一种指针的概念，把一个变量所在的内存单元的地址保存在另外一个内存单元中，保存地址的这个内存单元称为指针，通过指针和间接寻址访问变量，这种指针在C语言中可以用一个指针类型的变量表示，例如某程序中定义了以下全局变量：</p><pre class="programlisting">int i;
int *pi = &amp;i;
char c;
char *pc = &amp;c;</pre><p>这几个变量的内存布局如下图所示，在初学阶段经常要借助于这样的图来理解指针。</p><div class="figure"><a id="id2810538"></a><p class="title"><b>图 23.1. 指针的基本概念</b></p><div class="figure-contents"><div><img src="images/pointer.pointer0.png" alt="指针的基本概念" /></div></div></div><br class="figure-break" /><p>这里的<code class="literal">&amp;</code>是取地址运算符（Address Operator）<a id="id2810563" class="indexterm"></a>，<code class="literal">&amp;i</code>表示取变量<code class="literal">i</code>的地址，<code class="literal">int *pi = &amp;i;</code>表示定义一个指向<code class="literal">int</code>型的指针变量<code class="literal">pi</code>，并用<code class="literal">i</code>的地址来初始化<code class="literal">pi</code>。我们讲过全局变量只能用常量表达式初始化，如果定义<code class="literal">int p = i;</code>就错了，因为<code class="literal">i</code>不是常量表达式，然而用<code class="literal">i</code>的地址来初始化一个指针却没有错，因为<code class="literal">i</code>的地址是在编译链接时能确定的，而不需要到运行时才知道，<code class="literal">&amp;i</code>是常量表达式。后面两行代码定义了一个字符型变量<code class="literal">c</code>和一个指向<code class="literal">c</code>的字符型指针<code class="literal">pc</code>，注意<code class="literal">pi</code>和<code class="literal">pc</code>虽然是不同类型的指针变量，但它们的内存单元都占4个字节，因为要保存32位的虚拟地址，同理，在64位平台上指针变量都占8个字节。</p><p>我们知道，在同一个语句中定义多个数组，每一个都要有<code class="literal">[]</code>号：<code class="literal">int a[5], b[5];</code>。同样道理，在同一个语句中定义多个指针变量，每一个都要有<code class="literal">*</code>号，例如：</p><pre class="programlisting">int *p, *q;</pre><p>如果写成<code class="literal">int* p, q;</code>就错了，这样是定义了一个整型指针<code class="literal">p</code>和一个整型变量<code class="literal">q</code>，定义数组的<code class="literal">[]</code>号写在变量后面，而定义指针的<code class="literal">*</code>号写在变量前面，更容易看错。定义指针的<code class="literal">*</code>号前后空格都可以省，写成<code class="literal">int*p,*q;</code>也算对，但<code class="literal">*</code>号通常和类型<code class="literal">int</code>之间留空格而和变量名写在一起，这样看<code class="literal">int *p, q;</code>就很明显是定义了一个指针和一个整型变量，就不容易看错了。</p><p>如果要让<code class="literal">pi</code>指向另一个整型变量<code class="literal">j</code>，可以重新对<code class="literal">pi</code>赋值：</p><pre class="programlisting">pi = &amp;j;</pre><p>如果要改变<code class="literal">pi</code>所指向的整型变量的值，比如把变量<code class="literal">j</code>的值增加10，可以写：</p><pre class="programlisting">*pi = *pi + 10;</pre><p>这里的<code class="literal">*</code>号是指针间接寻址运算符（Indirection Operator）<a id="id2810828" class="indexterm"></a>，<code class="literal">*pi</code>表示取指针<code class="literal">pi</code>所指向的变量的值，也称为Dereference<a id="id2810848" class="indexterm"></a>操作，指针有时称为变量的引用（Reference）<a id="id2810856" class="indexterm"></a>，所以根据指针找到变量称为Dereference。</p><p><code class="literal">&amp;</code>运算符的操作数必须是左值，因为只有左值才表示一个内存单元，才会有地址，运算结果是指针类型。<code class="literal">*</code>运算符的操作数必须是指针类型，运算结果可以做左值。所以，如果表达式<code class="literal">E</code>可以做左值，<code class="literal">*&amp;E</code>和<code class="literal">E</code>等价，如果表达式<code class="literal">E</code>是指针类型，<code class="literal">&amp;*E</code>和<code class="literal">E</code>等价。</p><p>指针之间可以相互赋值，也可以用一个指针初始化另一个指针，例如：</p><pre class="programlisting">int *ptri = pi;</pre><p>或者：</p><pre class="programlisting">int *ptri;
ptri = pi;</pre><p>表示<span class="emphasis"><em><code class="literal">pi</code>指向哪就让<code class="literal">ptri</code>也指向哪</em></span>，本质上就是把变量<code class="literal">pi</code>所保存的地址值赋给变量<code class="literal">ptri</code>。</p><p>用一个指针给另一个指针赋值时要注意，两个指针必须是同一类型的。在我们的例子中，<code class="literal">pi</code>是<code class="literal">int *</code>型的，<code class="literal">pc</code>是<code class="literal">char *</code>型的，<code class="literal">pi = pc;</code>这样赋值就是错误的。但是可以先强制类型转换然后赋值：</p><pre class="programlisting">pi = (int *)pc;</pre><div class="figure"><a id="id2811004"></a><p class="title"><b>图 23.2. 把<code class="literal">char *</code>指针的值赋给<code class="literal">int *</code>指针</b></p><div class="figure-contents"><div><img src="images/pointer.pointer1.png" alt="把char *指针的值赋给int *指针" /></div></div></div><br class="figure-break" /><p>现在<code class="literal">pi</code>指向的地址和<code class="literal">pc</code>一样，但是通过<code class="literal">*pc</code>只能访问到一个字节，而通过<code class="literal">*pi</code>可以访问到4个字节，后3个字节已经不属于变量<code class="literal">c</code>了，除非你很确定变量<code class="literal">c</code>的一个字节和后面3个字节组合而成的<code class="literal">int</code>值是有意义的，否则就不应该给<code class="literal">pi</code>这么赋值。因此使用指针要特别小心，很容易将指针指向错误的地址，访问这样的地址可能导致段错误，可能读到无意义的值，也可能意外改写了某些数据，使得程序在随后的运行中出错。有一种情况需要特别注意，定义一个指针类型的局部变量而没有初始化：</p><pre class="programlisting">int main(void)
{
	int *p;
	...
	*p = 0;
	...
}</pre><p>我们知道，在堆栈上分配的变量初始值是不确定的，也就是说指针<code class="literal">p</code>所指向的内存地址是不确定的，后面用<code class="literal">*p</code>访问不确定的地址就会导致不确定的后果，如果导致段错误还比较容易改正，如果意外改写了数据而导致随后的运行中出错，就很难找到错误原因了。像这种指向不确定地址的指针称为“<span class="quote">野指针</span>”（Unbound Pointer）<a id="id2811122" class="indexterm"></a>，为避免出现野指针，在定义指针变量时就应该给它明确的初值，或者把它初始化为<code class="literal">NULL</code>：</p><pre class="programlisting">int main(void)
{
	int *p = NULL;
	...
	*p = 0;
	...
}</pre><p><code class="literal">NULL</code>在C标准库的头文件<code class="literal">stddef.h</code>中定义：</p><pre class="programlisting">#define NULL ((void *)0)</pre><p>就是把地址0转换成指针类型，称为空指针，它的特殊之处在于，操作系统不会把任何数据保存在地址0及其附近，也不会把地址0~0xfff的页面映射到物理内存，所以任何对地址0的访问都会立刻导致段错误。<code class="literal">*p = 0;</code>会导致段错误，就像放在眼前的炸弹一样很容易找到，相比之下，野指针的错误就像埋下地雷一样，更难发现和排除，这次走过去没事，下次走过去就有事。</p><p>讲到这里就该讲一下<code class="literal">void *</code>类型了。在编程时经常需要一种通用指针，可以转换为任意其它类型的指针，任意其它类型的指针也可以转换为通用指针，最初C语言没有<code class="literal">void *</code>类型，就把<code class="literal">char *</code>当通用指针，需要转换时就用类型转换运算符<code class="literal">()</code>，ANSI在将C语言标准化时引入了<code class="literal">void *</code>类型，<code class="literal">void *</code>指针与其它类型的指针之间可以隐式转换，而不必用类型转换运算符。注意，只能定义<code class="literal">void *</code>指针，而不能定义<code class="literal">void</code>型的变量，因为<code class="literal">void *</code>指针和别的指针一样都占4个字节，而如果定义<code class="literal">void</code>型变量（也就是类型暂时不确定的变量），编译器不知道该分配几个字节给变量。同样道理，<code class="literal">void *</code>指针不能直接Dereference，而必须先转换成别的类型的指针再做Dereference。<code class="literal">void *</code>指针常用于函数接口，比如：</p><pre class="programlisting">void func(void *pv)
{
	/* *pv = 'A' is illegal */
	char *pchar = pv;
	*pchar = 'A';
}

int main(void)
{
	char c;
	func(&amp;c);
	printf("%c\n", c);
...
}</pre><p>下一章讲函数接口时再详细介绍<code class="literal">void *</code>指针的用处。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch23.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="ch23.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="ch23s02.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 23 章 指针 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 2. 指针类型的参数和返回值</td></tr></table></div></body></html>
